<h1>ChUI.js</h1>

<p>ChUI.js is the file that brings all the layouts and widgets to life. It provides methods to create widgets on the fly, or to initialize existing markup. There is only one ChUI.js file for all three operating systems. It detects the operating system at load type and when needed, makes adjustments to widgets. If you are experiencing some OS specific problem that you would like to adjust for, you can use the properties that ChUI.js exposes.</p>

<a name="events"></a>
<h2>Events</h2>

<p>ChUI.js provides a number of variables to abstract the user input interaction from the device input. This allows you to use one event input for mouse, finger or stylus on desktop and mobile.</p>

<h3>$.eventStart</h3>

<p>This is equivalent to a mousedown, touchstart or MSPointerDown/pointerdown event.</p>

<h3>$.eventMove</h3>

<p>This is equivalent to a mousemove, touchmove or MSPointerMove/pointermove event.</p>

<h3>$.eventEnd</h3>

<p>This is equivalent to a mouseup, touchend or MSPointerUP/pointerup event.</p>

<h3>$.eventCancel</h3>

<p>This is equivalent to a mousecancel, touchcancel or MSPointerCancel/pointercancel event.</p>

<h3>$.gestureLength</h3>

<p>This is used by ChUI.js to define how far a user must drag the mouse, stylus or finger before a swipe gesture is registered. The default value is 30 pixels. Decreasing this might cause swipe gestures being registered too easily for the user to interact with other controls that expect taps/clicks/touches. Increasing it will make the shorter swipes harder to detect. If you want to register swipe events, 30 to 50 is the optimal amount.</p>

<a name="Uuid"></a>
<h2>$.Uuid</h2>

<p>This is a method that creates a uuid. This is used internally by ChUI when it needs to dynamically create ids for elements that don't have one. You can also use it when you need a unique identification value.</p>

<a name="UITrackHashNavigation"></a>
<h2>$.UITrackHashNavigation</h2>

<p>This method is used internally by ChUI.js with navigation list. It puts a hash value in the url of the window.location, allowing you to use client side routing with your navigation.</p>

<a name="UISetHashOnUrl"></a>
<h2>$.UISetHashOnUrl</h2>

<p>This method is used by $.UITrackHashNavigation.</p>

<a name="UIGoBackToArticle"></a>
<h2>$.UIGoBackToArticle</h2>

<p>This method is used for non-linear navigation back to an arbitrary article. By default a button with the class 'back' will always navigate back to the previous article (which will also have a class of 'previous'). If you want the enable the user to return to an article further back in the navigation history, you can use this method. It will also reset the navigation history array so that it reflects the current navigation state.</p>

<a name="UIGoBack"></a>
<h2>$.UIGoBack</h2>

<p>This method returns the user to the previous article. It gets executed automatically when the user interacts with a back button. You do not every need to use it.</p>

<a name="isNavigating"></a>
<h2>$.isNavigating</h2>

<p>This is a value used by ChUI.js to keep track of the progress of a navigation animation. By default it is false, when navigation begins it is set to true, and when navigation is complete it is set back to false. This is tested during user interaction with navigation lists so that the user cannot fire more than one navigation event at a time.</p>

<a name="UIGoToArticle"></a>
<h2>$.UIGoToArticle</h2>

<p>This method is used by navigation lists. When you set up a navigation list, user interaction with it will automatically execute this method. You can also use it to direct a user to a specific article, perhaps through interaction with a button. In that case you would need to hook up an event listener to do so. To navigate to a particule article, just provide its id. The method will implement the animate effect for you:</p>

<pre class="prettyprint"><code>$.UIGoToArticle('#picutres');
</code></pre>

<a name="NavigationEnd"></a>
<h2>NavigationEnd Event</h2>

<p>ChocolateChip-UI creates a navigationend event that you can use to know when an article has finished transitioning. This event fires everytime an article transitions into view, so this will happen when the user naivgates forward and backward. For Android and iOS this only fires for navigation lists. On Windows 8.x or Windows Phone 8 this also happens with tab bars because they slide the article in and out.</p>

<p>The following example shows how to filter out back navigation to an article with an id of "main":</p>

<pre class="prettyprint"><code>$(function() {
  $('article').on('navigationend', function() {
    if (this.id !== 'main') {
       console.log('Navigation just ended: ' + this.id);
    }
  })
});
</code></pre>

<a name='UIEditList'></a>
<h2>[].UIEditList (version 3.7.0 and later)</h2>

<p>As of version 3.7.0, ChocolateChip-UI offers the ability to make a list editable. This means that by tapping the "Edit" button, the user and delete or reorder the items in the list. Previously, in version 3.6.3 and earlier, you could only enable the ability of deleting list items using <code>UIDeletable</code>. You can read about that method below if you are using an earlier version of ChocolateChip-UI.</p>

<p>Using a callback on the Done button, you can persist the changes that the user maeks. To make a list deletable, just execute `UIEditList` on it and pass it a number of options. Possible options are, a name for the Edit button, Done button, Delete button, and a callback to execute when the user is done. You can also set two flags -- `deletable` or `movable` tof false to limit the edit functionality to one or the other. This is useful where you only want the user to be able to either reorder or delete items in a list, but not both. By default both are enabled. The values for the buttons are to enable localization, otherwise the deraults will be used.</p>

<p>You can turn any type of list into an editable list. This means you can enable users to rearrange or delete list items. You can choose whether to allow both or only one of these depending on your need. You just need to pass in the necessary options to the constructor. You can use the following options to customize the editable list:</p>

<pre class='prettyprint'><code>var options = {
  editLabel : labelName,
  doneLabel : labelName,
  deleteLabel : labelName,
  callback : callback (Tapping "Done" fires this),
  deletable: false (no deletables),
  movable: false (no movables)
}
</code></pre>

<p>The defaults for these are as follows, so if you want something different, you will need to override them by supplying your own values as options:</p>

<pre class='prettyprint'><code>editLabel : 'Edit',
doneLabel : 'Done',
deleteLabel : 'Delete',
callback : $.noop,
deletable: true,
movable: true
</code></pre>

<p>If we set deletable to false, the list will only allow the user to change the order of list items. Or iff we set movable to false, then the user would only be to delete list items. If we wanted the buttons to have different names, especially for localization, we would need to supply those as options:</p>

<pre class='prettyprint'><code>var options = {
  editLabel : 'Editar',
  doneLabel : 'OK',
  deleteLabel : 'Eliminar'
}
</code></pre>

<p>To initialize the list, you execute <code>UIEditList</code> directly on it:</p>

<pre class='prettyprint'><code>$('#myList').UIEditList({
  // options here
});
</code></pre>

<p>To do something when the user deletes an item, you can pass a callback:</p>

<pre class='prettyprint'><code>$('#myList').UIEditList({
  callback : function(item) {
    alert('You deleted item: ' $('item').text());
  }
});
</code></pre>

<p>Here's a more complex callback to store the results in localStorage:</p>

<pre class='prettyprint'><code>$('#editList').UIEditList({
  // Define callback for "Done" button:
  callback: function(item) {
    var text = $(item).siblings('h3').text();
    $('#response').html('You deleted: ' + text + '');
    var tempArray = [];
    $('#editList').find('li').each(function(_, ctx) {
      tempArray.push($(ctx).attr('data-list-item-value'));
    });
    tempArray = "'" + JSON.stringify(tempArray) + "'";
    try {
      localStorage.setItem('chosen-items', tempArray);
    } catch(err) {
      return
    }
  }  
});
</code></pre>

<p>As of version 3.8.3, ChocolateChip-UI's editable lists also output the following two values on a list:</p>

<ol>
  <li>data-list-items-position</li>
  <li>data-list-items-deleted</li>
</ol>

<p>If a user moves or deletes and item, these values get updated when the user taps the "Done" button. In the case of the attribute <code>data-list-items-position</code>, by default it contains a comma-separated list of the index of items in the list. Please not that these values are zero-based. So, if there were four items, its value would be "0,1,2,3". Supposed the user moved the first item to last position and tapped done, then this value would be "1,2,3,0". If the user deletes items, their index is output as a comma-separated list to the <code>data-list-items-deleted</code> attribute. For example if the user deleted item two and four, <code>data-list-items-deleted's</code> value would be "1,3".</p>
<p>By querying these values, you can convert them into an array using something like this:</p>

<pre class='prettyprint'><code>var movedItems = $('#myList').attr('data-list-items-position');
if (movedItems) {
  movedItems = movedItems.split(',');
}
</code></pre>

<p>You could then compare the array of moved items against an array of the original items before they were rendered in the app. You could then persist the new order by posting this data back to a server. You would do something similar for deleted items.</p>


<a name="UIDeletable"></a>
<h2>$.UIDeletable (version 3.6.3 and earlier)</h2>

<p>This method will enable the deletion of list items. It does this by inserting an 'Edit' button on the right side of the nav. You can also provide a callback to execute when and item is deleted.</p>

<pre class="prettyprint"><code>$(function() {
  $.UIDeletable({
   list: '#myList',
   callback: function(item) {
     var text = $(item).siblings('h3').text();
     $('#response').html('You deleted: &lt;strong&gt;' + text + '&lt;/strong&gt;');
   }
  });
});
</code></pre>

<p>If you allow the user to delete items from a list, you may walso want to also update your server side data. You could do this by posting the necessary info when the user deletes an item.</p>

<p>If you want to add list items to a deletable list after it's inital load, you can do so. Just insert the list items with the markup necessary to match your other list items, then reinitialize the deleteable list with the same options that you used originally. If you are going to do this often, you might want to just assign the <code>$.UIDeletable</code> setup to a variable so you can just use that:</p>

<pre class="prettyprint"><code>var initDeletables = $.UIDeletable({
  list: '#myList',
  callback: function(item) {
   var text = $(item).siblings('h3').text();
   $('#response').html('You deleted: &lt;strong&gt;' + text + '&lt;/strong&gt;');
  }
});
</code></pre>

<p>Then later, after adding more items to the deletable list you can reinitialize it like this:</p>

<pre class="prettyprint"><code>initDeletables();
</code></pre>


<a name="UIPaging"></a>
<h2>$.UIPaging</h2>

<p>To make a paging control, you first need to have the necessary markup for the paging mechanism. Initialization is simple: <code>$.UIPaging()</code>. You need to have a segmented control that will toggle an article's sections.</p>

<p><strong>Example:</strong></p>

<p>(version 3.8.0 and later):</p>
<pre class="prettyprint"><code>&lt;nav&gt;
&lt;h1&gt;Paging&lt;/h1&gt;
  &lt;div class='segmented paging horizontal align-flush'&gt;
    &lt;button title='previous panel'&gt;&lt;/button&gt;
    &lt;button title='next panel'&gt;&lt;/button&gt;
  &lt;/div&gt;
&lt;/nav&gt;
&lt;article id="main" class="current paging"&gt;
  &lt;section class='current'&gt;
    &lt;h2&gt;First Article&lt;/h2&gt;
    &lt;ul class='list'&gt;
      &lt;li&gt;
        &lt;h3&gt;Thing One&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/section&gt;
  &lt;section&gt;
    &lt;h2&gt;Second Article&lt;/h2&gt;
    &lt;ul class='list'&gt;
      &lt;li&gt;
        &lt;h3&gt;Item One&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/section&gt;
  &lt;section&gt;
    &lt;h2&gt;Third Article&lt;/h2&gt;
    &lt;ul class='list'&gt;
      &lt;li&gt;
        &lt;h3&gt;Item 1&lt;/h3&gt;
        &lt;cellsubtitle&gt;Item 1 Subtitle&lt;/cellsubtitle&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/section&gt;
&lt;/article&gt;
</code></pre>


<p>(version 3.7.0 and earlier):</p>
<pre class="prettyprint"><code>&lt;nav&gt;
&lt;h1&gt;Paging&lt;/h1&gt;
  &lt;div class='segmented paging horizontal align-flush'&gt;
    &lt;a class='button' href='javascript:void(null)' title='previous panel'&gt;&lt;/a&gt;
    &lt;a class='button' href='javascript:void(null)' title='next panel'&gt;&lt;/a&gt;
  &lt;/div&gt;
&lt;/nav&gt;
&lt;article id="main" class="current paging"&gt;
  &lt;section class='current'&gt;
    &lt;h2&gt;First Article&lt;/h2&gt;
    &lt;ul class='list'&gt;
      &lt;li&gt;
        &lt;h3&gt;Thing One&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/section&gt;
  &lt;section&gt;
    &lt;h2&gt;Second Article&lt;/h2&gt;
    &lt;ul class='list'&gt;
      &lt;li&gt;
        &lt;h3&gt;Item One&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/section&gt;
  &lt;section&gt;
    &lt;h2&gt;Third Article&lt;/h2&gt;
    &lt;ul class='list'&gt;
      &lt;li&gt;
        &lt;h3&gt;Item 1&lt;/h3&gt;
        &lt;cellsubtitle&gt;Item 1 Subtitle&lt;/cellsubtitle&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/section&gt;
&lt;/article&gt;
</code></pre>
<a name="UISlideout"></a>
<h2>$.UISlideout</h2>

<p>This method creates an empty slide out menu for your app. It also puts the slide out icon in the top left of your nav bar. By executing the function, all interactions are automatic, you just need to provide the interactive content inside the slide out for your uses to use. You could use the <code>[].append()</code> method or a template to do this or any of the other ways to output content to the slide out. Your choice.</p>

<p><strong>Example:</strong></p>

<pre class="prettyprint"><code>// Create an empty slide out menu:
$.UISlideout();
</code></pre>

<p>The easiest way to make the slide out interactive is to use the <code>$.UISlideout.populate</code> method described below.</p>

<a name="UISlideout_populate"></a>
<h2>$.UISlideout.populate</h2>

<p>As of Version 3.0.6, ChocolateChip-UI offers this method to quickly create an interactive navigable list for slide outs.</code>.</p>

<p>This method takes one argument, an array of objects with key/values. The key is the id of the article to show when tapped, and the value is the label that will show in the slide out list.</p>

<pre class="prettyprint"><code>// Create an empty slide out menu:
$.UISlideout();
// Populate the slide out:
$.UISlideout.populate([{music:'Music'},{pictures:'Pictures'},{recipes:'Recipes'},{contacts:'Contacts'}]);
</code></pre>

<p>The above would result in a list as follows:</p>

<pre class="prettyprint"><code>&lt;ul class="list"&gt;
  &lt;li data-show-article="music"&gt;
    &lt;h3&gt;Music&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li data-show-article="pictures"&gt;
    &lt;h3&gt;Pictures&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li data-show-article="recipes"&gt;
    &lt;h3&gt;Recipes&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li data-show-article="contacts"&gt;
    &lt;h3&gt;Contacts&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>You can also add headers to the slide out list using the keyword <code>header</code> and a value for its label. This will be output a list item with the class <code>slideout-header</code> and an <code>h2</code> for the header itself. We'll take the above example and add two headers to break the list up. We just need to add two new key/value pairs with a key of <code>header</code> and the value for our header. The headers will be "Media" and "Miscellaneous."</p>


<pre class="prettyprint"><code>// Create an empty slide out menu:
$.UISlideout();
// Populate the slide out:
$.UISlideout.populate([{header:'Media'},{music:'Music'},{pictures:'Pictures'},{header:'Miscellaneous'},{recipes:'Recipes'},{contacts:'Contacts'}]);
</code></pre>

<p>This will produce the following:</p>

<pre class="prettyprint"><code>&lt;ul class="list"&gt;
  &lt;li class="slideout-header"&gt;
    &lt;h2&gt;Media&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li data-show-article="music"&gt;
    &lt;h3&gt;Music&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li data-show-article="pictures"&gt;
    &lt;h3&gt;Pictures&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li class="slideout-header"&gt;
    &lt;h2&gt;Miscellaneous&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li data-show-article="recipes"&gt;
    &lt;h3&gt;Recipes&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li data-show-article="contacts"&gt;
    &lt;h3&gt;Contacts&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>Because the populate method uses the keyword "header" to create headers in the slide out, you won't be able to have it work with an article that has an id of "header". Anyway, you should never have an article named header. And article is not a header for anything.</p>

<h3>Customize the Slide Out</h3>

<p>You can pass in some options to modify the behavior of the slide out. Possible values are <code>dynamic: true</code> or a callback. Passing the "dynamic" value allows you to override the default multi-article nature of the slide out and instead have just one article which you can populate based on which slide out menu item the user tapped. In this case you'd also want to define a callback to handle user interaction. It will get passed a refer to the item the user tapped. Using that you can determine which item and then update the article appropriately.</p>

<p>Here's what your markup might look like:</p>

<pre class="prettyprint"><code>
&lt;nav class="current"&gt;
  &lt;h1&gt;&lt;/h1&gt;
&lt;/nav&gt;
&lt;article class="current" id="main"&gt;
  &lt;section&gt;
    &lt;aside&gt;&lt;img src="" alt="" height="60" /&gt;&lt;/aside&gt;
    &lt;h2&gt;Benefits&lt;/h2&gt;
    &lt;ul class='list' id='benefits'&gt;
      &lt;li&gt;
        &lt;h3&gt;&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
     &lt;h2&gt;Uses&lt;/h2&gt;
     &lt;ul class="list" id='uses'&gt;
     &lt;/ul&gt;
  &lt;/section&gt;
&lt;/article&gt;
 </code></pre>


<p>You might initialize your slideout with something like this. Notice that the second argumet to the callback will be the element tapped by the user "li".</p>
<pre class="prettyprint"><code>
$.UISlideout({dynamic: true, callback: function(e, li) {
  var fruit = $(li).index();
  renderChosenFruit(fruit);
}});

// Populate the menu:
$.UISlideout.populate([
  {header:'Fruits'},
  {Apples:'Apples'},
  {Oranges:'Oranges'},
  {Bananas:'Bananas'},
  {Mangos:'Mangos'},
  {Avocados:'Avocados'}
]);

// We're assuming "fruitsData" is an array 
// of data which you've gotten somehow (Ajax):

var renderChosenFruit = function(fruit) {
  $('h1').text(fruitsData[fruit].name);
  $('aside img')[0].src = fruitsData[fruit].image;
  $('#benefits h3').text(fruitsData[fruit].benefit);
  $('#uses').empty();
  fruitsData[fruit].uses.forEach(function(use) {
    $('#uses').append('&lt;li>&lt;h3&gt;' + use + '&lt;/h3&gt;&lt;/li&gt;');
  });
};
</code></pre>

<a name="UICreateSwitch"></a>
<h2>$.UICreateSwitch</h2>

<p>A switch control can be created manually using a span with a class 'switch'. You can set its state to on by adding it as a class. Without the class 'on' is the off state. Add a checkbox input and give it a value. At load time ChUI.js will initialize the switch with basic interactivity. You'll need to register and event to do something with it. Check the example below:</p>

<pre class="prettyprint"><code>&lt;li class='comp'&gt;
  &lt;div&gt;
    &lt;h3&gt;Sleep&lt;/h3&gt;
  &lt;/div&gt;
  &lt;aside&gt;
    &lt;span class="switch on" id="sleepSwitch"&gt;
      &lt;input type="checkbox" value="Sleep" name="sleepSwitch"&gt;
    &lt;/span&gt;
  &lt;/aside&gt;
&lt;/li&gt;

&lt;script&gt;
  $('#sleepSwitch').on('singletap', function() {
    if (this.classList.contains('on')) {
      $('#response').html($(this).find('input').val());
    } else {
      $('#response').empty();
    }
  });
&lt;/script&gt;
</code></pre>

<p>As of version 3.8.0, ChocolateChip-UI uses Google's Material Design look for switches, which are small globes on a sliding track. If you prefer the original rectangular switches you can get them to render by adding the class "traditional" to the switch after the switch class:</p>

<pre class="prettyprint"><code>&lt;li class='comp'&gt;
  &lt;div&gt;
    &lt;h3&gt;Sleep&lt;/h3&gt;
  &lt;/div&gt;
  &lt;aside&gt;
    &lt;span class="switch traditional on" id="sleepSwitch"&gt;
      &lt;input type="checkbox" value="Sleep" name="sleepSwitch"&gt;
    &lt;/span&gt;
  &lt;/aside&gt;
&lt;/li&gt;
</code></pre>

<p>You can also create a switch dynamically using the <code>$.UICreateSwitch</code> method. You give it an object with the values for your switch:</p>

<pre class="prettyprint"><code>var sleepSwitch = {
  id : "sleepSwitch",
  state : "on",
  name : "activity.choice",
  value: "sleep"
};
// Insert switch into the aside of list item 4:
$('.list > li').eq(3).find('aside').prepend( $.UICreateSwitch(sleepSwitch) );
// Initialize the switch:
$('.switch').UISwitch();</code></pre>

<p>If you wish to create a switch for Android with the old, rectangular look, just pass the contsructor the property <code>style: "traditional"</code>:</p>

<pre class="prettyprint"><code>var sleepSwitch = {
  id : "sleepSwitch",
  state : "on",
  name : "activity.choice",
  value: "sleep",
  style: "traditional"
};
// Insert switch into the aside of list item 4:
$('.list > li').eq(3).find('aside').prepend( $.UICreateSwitch(sleepSwitch) );
// Initialize the switch:
$('.switch').UISwitch();</code></pre>

<a name="UISwitch"></a>
<h2>[].UISwitch</h2>

<p>This method initializes any uninitialized switches. You execute it by doing a search for switches using the <code>.switch</code> selector:</p>

<pre class="prettyprint"><code>$('.switch').UISwitch();
</code></pre>

<a name="UICreateSegmented"></a>
<h2>$.UICreateSegmented</h2>

<p>You can create a segmented control dynamically with this method. You supply the following values:</p>

<pre class="prettyprint"><code>var segmentedOptions = {
  id: 'mySegmented',
  labels : ['Radioactive','Hurt','Yeah, Yeah'],
  selected: 0
};
var newSegmented = $.UICreateSegmented(segmentedOptions);
// Insert the segemented control into the document:
$('#segmentedPanel').append(newSegmented);
</code></pre>

<p>After inserting the segmented control, you need to initialize it, at which time you can also attach and event listener to handle user interaction:</p>

<pre class="prettyprint"><code>// The parameter "item" will refer to the selected segmented:
var segmentedResponse = function(item) {
  // Output the index number of the selected segment:
  $('#output').find('h3').html(($(item).index()));
};
// Initialize the segmented control:
$('#mySegmented').UISegmented({ callback:segmentedResponse });
</code></pre>

<a name="UISegmented"></a>
<h2>[].UISegmented</h2>

<p>This method is executed on a segmented selector to initialize it. You can provide a callback to execute when the user interacts with it:</p>

<pre class="prettyprint"><code>$('#mySegmented').UISegmented({ callback:segmentedResponse });
</code></pre>

<a name="UIPopup"></a>
<h2>$.UIPopup</h2>

<p>You can create a popup using the <code>$.UIPopup</code> method. Every popup will have at least a cancel button. This button will close the popup without you needed to write any code. You can also provide another button to perform an affirmative action (continueButton). You can provide a callback that will be executed when this button is pressed. You can provide label values for both buttons to customize them.</p>

<p>When you show a popup, the method will also create a semi transparent mask over the app to prevent user interaction. When you dispel the popup, the mask is also dispelled.</p>

<p>You can register an event to dynamically create and show the popup:</p>

<pre class="prettyprint"><code>// Bind event to show the popup:
$("#openPopup").bind("singletap", function() {
  $.UIPopup({
    selector: "#main",
    id: "warning",
    title: 'Attention Viewers!',
    message: 'This is a message from the sponsors. Please be seated while we are getting ready. Thank you for your patience.',
    cancelButton: 'Skip',
    continueButton: 'Stay for it',
    callback: function() {
      var popupMessageTarget = document.querySelector('#popupMessageTarget');
      popupMessageTarget.textContent = 'Thanks for staying with us a bit longer.';
      popupMessageTarget.className = "";
      popupMessageTarget.className = "animatePopupMessage";
    }
  });
});
</code></pre>

<a name="UIPopupClose"></a>
<h2>[].UIPopupClose</h2>

<p>This method will close the popup, dispelling the mask as well. This method gets executed automatically when the user presses the cancel or continue buttons in the popup.</p>

<a name="UICenterPopup"></a>
<h2>$.UICenterPopup</h2>

<p>This method is used by ChUI.js to center any active popup. You don't need to ever use it yourself.</p>

<a name="UITabbar"></a>
<h2>$.UITabbar</h2>

<p>This method is used to create a tab bar interface. For arguments, it expects an id for the tab bar, the number of tabs you want, labels for the tabs, icons for the tabs (these only get display on iOS), and a selected tab. By default the first tab will be selected, so if that is your choice, you do not need to provide a value. If you want another tab to be the selected one, provide its zero-based position. Unlike a paging control, which enables you to navigate through an article's collection of sections, the tab bar is for toggling through a group of articles. A tab bar is used when your app has a small number of articles with each doing something unique and they do not navigate to other articles.</p>

<pre class="prettyprint"><code>$(function() {
  var opts = {
    tabs : 5,
	  imagePath : "../icons-ios/",
	  icons : ["music", "pictures", "documents", "downloads", "favorites"],
	  labels : ["Music", "Pictures", "Documents", "Downloads", "Favorites"],
	  selected : 1
  };
  $.UITabbar(opts);
});
</code></pre>

<a name="UISheet"></a>
<h2>$.UISheet</h2>

<p>This method is used to create a generic sheet. This is an overlay that slides across the screen, covering it. It has a handle across the top. Pressing it will close the sheet. It also has a section tag which provides vertical scrolling for any content you put within it. On iOS the sheet slides up from the bottom. On Android and Windows Phone 8 it slides down from the top. You create a sheet as follows:</p>

<pre class="prettyprint"><code>$(function() {
  // Create an empty sheet:
  $.UISheet({id: "mySheet"});

  // Get the sheet and append some markup:
  $('.sheet').find('section').append("&lt;ul class='list'&gt;&lt;/li&gt;&lt;li&gt;&lt;a class='button' href='javascript:void(null)'&gt;Save&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class='button' href='javascript:void(null)'&gt;Delete&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class='button' href='javascript:void(null)'&gt;Cancel&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;");
  $('.sheet .list').append ('&lt;h2 style="text-align: center; margin: 20px;"&gt;The End&lt;/h2&gt;');

  // After append the sheet to the document,
  // register an event to handle the buttons, etc.
  // For ChUI version 3.7.0 and earlier, you'd need
  // to the class "button" instead of the tag "button".
  $('.sheet .list').on('singletap', 'button', function() {
    $.UIHideSheet();
  });

  // Initialize button to show sheet:
  $('#showSheet').on('singletap', function() {
    // Pass in the id of the sheet:
    $.UIShowSheet("#mySheet");
  });
});
</code></pre>

<a name="UIShowSheet"></a>
<h2>$.UIShowSheet</h2>

<p>After creating a sheet as illustrated above, you can show it by registering the $.UIShowSheet method on a user action:</p>

<pre class="prettyprint"><code>// Initialize button to show sheet:
$('#showSheet').on('singletap', function() {
  $.UIShowSheet();
});
</code></pre>

<p>Please note, if you have just one sheet in your app, executing <code>$.UIShowSheet()</code> without any arguments will show it. However, if you have more than one sheet, you will need to pass this method an id for each sheet. Of course you'll need to use the id that you provided when you initialized your sheets.</p>

<a name="UIHideSheet"></a>
<h2>$.UIHideSheet</h2>

<p>This method will dispel the sheet. You can register an event to do so:</p>

<pre class="prettyprint"><code>$('.sheet .list').on('singletap', 'button', function() {
  $.UIHideSheet();
});
</code></pre>

<h3>Customizing the Sheet</h3>

<p>You can eliminate the default handle in the sheet by passing the value: </p>
<pre class='prettyprint'><code>$.UISheet({id: 'mySheet', handle: false});</code></pre>


<a name="body"></a>
<h2>$.body</h2>

<p>This variable is a shortcut for the body element. Use it instead of $('body'). As a matter of fact, you should always assign an element to a variable when you will be accessing it multiple times, as that will be faster than doing a selector query each time.</p>

<p><strong>Example:</strong></p>

<pre class="prettyprint"><code>$.body.on('singleta', 'li', function() {
  alert($(this).text());
});
</code></pre>

<a name="UINavigationHistory"></a>
<h2>$.UINavigationHistory</h2>

<p>This is an array of the articles visited during a navigation event. It is used by ChUI.js to know which article to return to when the user hits the back button.</p>

<a name="UIPanelToggle"></a>
<h2>[].UIPanelToggle</h2>

<p>This method sets up a segmented control to toggle a series of panels.  This expects the following markup: a container div, no particular class required. Within it should be a series of divs as containers for the content to be toggles. Each one of these child divs constitutes a toggleable panel. The structure should be like this:</p>

<p>(version 3.8.0 and later):</p>
<pre class="prettyprint"><code>&lt;article id="main" class="current"&gt;
  &lt;section&gt;
    &lt;div class='horizontal centered'&gt;
      &lt;div class='segmented'&gt;
        &lt;button&gt;Radioactive&lt;/button&gt;
        &lt;button&gt;Hurt&lt;/button&gt;
        &lt;button&gt;Permanent&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- Container for toggleable panels --&gt;
    &lt;div id="toggle-panels"&gt;
      &lt;!-- toggleable panel  --&gt;
      &lt;div&gt;
        &lt;ul class='list'&gt;
          &lt;li&gt;
            &lt;h3&gt;Imagine Dragons&lt;/h3&gt;
            &lt;h4&gt;Radioactive&lt;/h4&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
      &lt;!-- toggleable panel --&gt;
      &lt;div&gt;
        &lt;ul class='list'&gt;
          &lt;li&gt;
            &lt;h3&gt;The Hurry and the Harm&lt;/h3&gt;
            &lt;h4&gt;Hurt&lt;/h4&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
      &lt;!-- toggleable panel --&gt;
      &lt;div&gt;
        &lt;ul class='list'&gt;
          &lt;li&gt;
            &lt;h3&gt;David Cook&lt;/h3&gt;
            &lt;h4&gt;Permanent&lt;/h4&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/article&gt;
</code></pre>


<p>(version 3.7.0 and earlier):</p>
<pre class="prettyprint"><code>&lt;article id="main" class="current"&gt;
  &lt;section&gt;
    &lt;div class='horizontal centered'&gt;
      &lt;div class='segmented'&gt;
        &lt;a class='button'&gt;Radioactive&lt;/a&gt;
        &lt;a class='button'&gt;Hurt&lt;/a&gt;
        &lt;a class='button'&gt;Permanent&lt;/a&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- Container for toggleable panels --&gt;
    &lt;div id="toggle-panels"&gt;
      &lt;!-- toggleable panel  --&gt;
      &lt;div&gt;
        &lt;ul class='list'&gt;
          &lt;li&gt;
            &lt;h3&gt;Imagine Dragons&lt;/h3&gt;
            &lt;h4&gt;Radioactive&lt;/h4&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
      &lt;!-- toggleable panel --&gt;
      &lt;div&gt;
        &lt;ul class='list'&gt;
          &lt;li&gt;
            &lt;h3&gt;The Hurry and the Harm&lt;/h3&gt;
            &lt;h4&gt;Hurt&lt;/h4&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
      &lt;!-- toggleable panel --&gt;
      &lt;div&gt;
        &lt;ul class='list'&gt;
          &lt;li&gt;
            &lt;h3&gt;David Cook&lt;/h3&gt;
            &lt;h4&gt;Permanent&lt;/h4&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/article&gt;
</code></pre>

<p>To make the above markup work as a toggleable panel control, we do the following:</p>

<pre class="prettyprint"><code>$(function() {
   $('.segmented').UIPanelToggle('#toggle-panels',function(){$.noop;});
});
</code></pre>

<a name="UISelectList"></a>
<h2>[].UISelectList</h2>

<p>This method turns a simple list into a selectable list. This just a fancy way of presenting the user with a group of radio buttons. In fact, ChUI.js inserts a radio button into each list item, although these are not visible to the user. You can set a selected state for the list, otherwise it will load with none selected. You can also provide a callback to execute when the user presses a list item. You can mark a list as a select list by putting the class <code>select</code> on it. If you don't, the initialization process will add it for you.</p>

<pre class="prettyprint"><code>$(function() {
  $('#seletlist').UISelectList({
    selected: 0,
    callback: function() {
      $("#response").html($(this).text());
    }
  });
});
</code></pre>

<p>You can create a list with data values on the list items using the attribute: <code>data-select-value</code>. When UISelectList runs, it will attach these values onto the radio button that belongs to each list item. That way you can get the value of the radio button when the user selects that list item.</p>

<p>You can add list items dynamically after the initial app load. You just need to make sure that you're added list items with everything they expect to work. The initialization added a data value to the list <code>data-select-value</code>. It also adds a hidden radio input with the form data for that item. This input needs to have the same name as the other radio inputs. If you provided a name for the radio inputs in your options, then use the same one. If you let $.UISelectList apply on automiatically, you'll need to grab that value from one of the list items to use for the new list items. If you create the new list items following all of these requirements, upon appending them to an existing selectable list, they will be selectable automatically.</p>

<a name="UIStepper"></a>
<h2>[].UIStepper</h2>

<p>This method will initialize a stepper control. You create a stepper by putting the markup in your document, either manually or dynamically. See the markup below:</p>

<pre class="prettyprint"><code>&lt;span class='stepper' id="digits"&gt;&lt;/span&gt;
</code></pre>

<p>To initialize it, we could do the following:</p>

<pre class="prettyprint"><code>$(function() {
  $('#digits').UIStepper({
    start: 1,
    end: 8,
    defaultValue: 3
  });
});
</code></pre>

<a name="UIBusy"></a>
<h2>[].UIBusy</h2>

<p>This method will create a busy indicator. The appearance will vary per operating system. You can customize the busy indicator with three values: color, size and position. The position option is for when you insert the busy indicator into a nav. Giving it a position of <code>align-flush</code> will put it flush against the right side of the screen. If you insert the busy indicator into a large container, you can center it using the UICenter method. Check out these examples:</p>

<pre class="prettyprint"><code>$('nav').find('.busy').css('top','10px');
$('nav').UIBusy({size: '20px', color:'#666', position: 'right'});

$('#busy1').UIBusy({'color':'rgba(200,0,0,0.75)', 'size': '50px'});
$('#busy1').find('.busy').UICenter();

$('#busy2').UIBusy({size:'40px', color: 'gold'});
$('#busy2').find('.busy').UICenter();

$('#busy3').UIBusy({color: '#fff'});
$('#busy3').find('.busy').UICenter();
</code></pre>

<p>You can create a modal busy indicator by first creating a popup and then inserting the busy indicator into it:</p>

<pre class="prettyprint"><code>$(function() {
  // When the user presses the showModalBusyIndicator button:
  $('#showModalBusyIndicator').on($.eventStart, function() {
    $.UIPopup({empty: true});
    $('.popup').UIBusy({'color':'blue', 'size': '80px'})
    setTimeout(function() {
       $('.popup').UIPopupClose()
    },5000);
  });
});
</code></pre>

<a name="UICenter"></a>
<h2>[].UICenter</h2>

<p>This method will center an absolutely positioned element on the screen. Just execute it directly on the element you want to center. It gets used by popups.</p>

<a name="UIBlock"></a>
<h2>[].UIBlock</h2>

<p>This method will create a semi-transparent mask over the screen. You can provide a value for the amount of opacity you want. It is also invoked automatically by popups and popovers. </p>

<p><strong>Example:</strong></p>

<pre class="prettyprint"><code>$.body.UIBlock();
</code></pre>

<a name="UIUnblock"></a>
<h2>[].UIUnblock</h2>

<p>This method will remove a mask from the screen. </p>

<p><strong>Example:</strong></p>

<pre class="prettyprint"><code>$.body.UIUnblock();
</code></pre>

<a name="UIPopover"></a>
<h2>$.UIPopover</h2>

<p>As of version 3.6.3, ChocolateChip-UI uses <code>$.UIPopover()</code> for creating popovers. Earlier versions used the <code>[].UIPopover()</code> for the same purpose and is descibed in detail after this.</p>

<p>Popovers are created with the <code>$.UIPopover()</code> method. You pass several values to it to define how you want it to displayed.</p>

<ul>
  <li>title: show only on iOS</li>
  <li>id: (optional)</li>
  <li>trigger: the button or other element serving as an anchor from which the popup appears and to which it is attached on the screen</li>
  <li>callback: executed when the user taps the popover content</li>
</ul>



<pre class="prettyprint"><code>// Define content for popover:
var popoverContent = "&lt;ul class='list'&gt;&lt;li&gt;&lt;h3&gt;Apples&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Oranges&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Bananas&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Pears&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Plums&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Cherries&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Apricots&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Lemons&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Peaches&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Pineapples&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Strawberries&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Guavas&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Grapefruit&lt;/h3&gt;&lt;/li&gt;&lt;/ul&gt;";

// Define handler for popover interaction:
var popoverEventHandler = function(whichPopover) {
  // Attach event to catch user interaction.
  // Use singletap to allow user to scroll content.
  $('.popover').on('singletap', function(e) {
    var listItem;
    if (e.target.nodeName === 'LI') {
      $(results).html(e.target.textContent.trim());
    } else {
      listItem = $(e.target).closest('li')[0];
      $(whichPopover).html(listItem.textContent.trim());
    }
    // Close the popover:
    $.UIPopoverClose();
  });
};

//////////////////////////////////////////
// Initialize popover.
// Attach event to button to show popover:
//////////////////////////////////////////
$('#showPopover').on('singletap', function() {
  // Save reference to button:
  var trigger = this;
  $.UIPopover({
    title: 'Fruits',
    trigger: trigger,
    content: popoverContent,
    callback: function() {
      popoverEventHandler('fruitsPopover');
    }
  });
});
</code></pre>

<p>Please look at the working example for popovers to see exactly how this is implemented.</p>


<h4>* Popovers for 3.6.2 and earlier</h4>
<h2>[].UIPopover</h2>
<p>Please note, this method only works with ChocolateChip-UI version 3.6.2 or earlier. For information about the latest popover method, please read the information before this.</p>
<p>This method will create a popover. To create a popover, you execute this method on the element you want to display the popover. In general, a button in the nav will display a popover. You provide the popover a title. This only gets displayed on iOS. Android and Windows Phone 8 do not show titles on their version of the popover. You provide a callback that gets executed when the users presses the button that creates the popover. You can use this to populate the popover. You create a popover as follows:</p>

<pre class="prettyprint"><code>// Initialize popover:
$('#showPopover').UIPopover({
  id: 'fruitsPopover',
  title: "Fruits",
  callback: fillPopover
});

// Define a callback for popover:
var fillPopover = function(popover) {
  // Populate Popover with content:
  $('.popover').find('section').append(popoverContent);

  // Event to execute when the user interacts with the popover:
  popoverEventHandler();
};

// Content for popover:
var popoverContent = "&lt;ul class='list'&gt;&lt;li&gt;&lt;h3&gt;Apples&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Oranges&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Bananas&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Pears&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Plums&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Cherries&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Apricots&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Lemons&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Peaches&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Pineapples&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Strawberries&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Guavas&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Grapefruit&lt;/h3&gt;&lt;/li&gt;&lt;/ul&gt;";


// Function to execute when the user interacts with the popover:
var popoverEventHandler = function() {
  // Attach event to catch user interaction.
  // Use singletap to allow user to scroll content.
  $('.popover').on('singletap', function(e) {
    var listItem;
    if (e.target.nodeName === 'LI') {
      $('#fruitsChoice').html(e.target.textContent.trim());
    } else {
      listItem = $(e.target).ancestor('li')[0];
      $('#fruitsChoice').html(listItem.textContent.trim());
    }
    $.UIPopoverClose();
  });
};
</code></pre>

<a name="UIAlignPopover"></a>
<h2>$.UIAlignPopover</h2>

<p>This method is used by ChUI.js to center any active popover. You don't need to ever use it yourself.</p>

<a name="UIPopoverClose"></a>
<h2>$.UIPopoverClose</h2>

<p>This method is used to dispel an active popover. This will also remove the mask created by UIBlock.</p>


<a name="UIHideNavBar"></a>
<h2>$.UIHideNavBar</h2>

<p>This method is used to temporarily hide the navbars. This can free up some extra space on screen. Remember to provide a way for the user to get the nav bars back. See <code>$.UIShowNavBar</code> below.</p>

<pre class="prettyprint"><code>// Hide all nav bars:
$.UIHideNavBar();
</code></pre>

<p>When using this method, be sure to provide some way to show the nav bars again. If you are doing this in some process that might error out, make sure that you use error detection to also reveal the nav bars again.</p>


<a name="UIShowNavBar"></a>
<h2>$.UIShowNavBar</h2>

<p>This method enables you to show all nav bars that were hidden using the method <code>$.UIHideNavBar()</code></p>

<pre class="prettyprint"><code>// Show all hidden nav bars:
$.UIShowNavBar();
</code></pre>

<a name="Gestures"></a>
<h2>Gestures:</h2>

<p>ChUI.js provides a number of gestures for you to use in your app. These get translated to appropriate events on each platform. They are as follows:</p>

<ul class='list'>
<li>tap</li>
<li>singletap</li>
<li>longtap</li>
<li>doubletap</li>
<li>swipe</li>
<li>swipeleft</li>
<li>swiperight</li>
<li>swipeup</li>
<li>swipedown</li>
</ul>

<p>Tap is a generic tap, this could be a singletap, doubletap or longtap event. The same with swipe, it will be either a left, right, up or down swipe. These two are not very useful unless you want to check for a very generic user interaction.</p>

<p>A singletap has a delay of 150 milliseconds. In general, if you want to interact with anything that is in a scrollable container, you want to use a singletap event. This will allow you to scroll without triggering an event on any actionable items in the container. You can register a singletap and a doubletap on the same element, or a longtap too, to set up different results. Swipes work just like any other events as well.</p>

<p>To use these gestures, put them in quotes just as you would any normal DOM event:</p>

<pre class="prettyprint"><code>$('a').on('singletap', function() {
  // Do stuff here
  alert('Single Tap');
});
$('button').on('doubletap', function() {
  // Do stuff here
  alert('Double Tap');
});
$('button').on('longtap', function() {
  // Do stuff here
  alert('Long Tap');
});
$('button').on('swipeleft', function() {
  // Do stuff here
  alert('Swipe Left');
});
$('button').on('swiperight', function() {
  // Do stuff here
  alert('Swipe Right');
});
</code></pre>

<a name="pubSub"></a>
<h1>Pub/Sub</h1>
<p>Pub/sub is a popular and useful programming pattern to help decouple code. This allows you to set up methods that "subscribe" to a topic, something like a radio channel. When you publish data to a topic, all methods that are subscribed to that topic will execute with that data. It thus provides an easy way to pass the same data to multiple functions without having to enclose them in one function.</p>

<p>When implementing a pub/sub pattern, be careful not to over use it, as it can sometimes be difficult to debug or run tests against.</p>

<a name="subscriptions"></a>
<h2>$.subscriptions</h2>
<p>The is a cache for all subscriptions. If you unsubscribe for a topic, the subscription will be removed.</p>

<p>By convention, topics used for subscriptions use forward slashes to demark namespaces, something like a rest interface.</p>

<pre class="prettyprint"><code>// Possible topics:
'user/new'
'user/current'
'purchases/songs'
'purchases/apps'</code></pre>

<a name="subscribe"></a>
<h2>$.subscribe</h2>
<p>To subscribe to a topic, you pass two arguments, a topic and a callback to execute when data gets published. It's a good idea to put in some data checks to see what kind of data is being received. That way you can choose not to do anything, or to use only certain parts of the data. The type of data could be any valid JavaScript type: string, array, object, etc. It's up to you to figure out where this data that you publish comes from. It might reside on the server, it could be dynamically generated by the server. It might come from any number of possible sources: Ajax requests, Web services, etc.</p>

<p>Below is an example of how to subscribe to a topic:</p>

<pre class="prettyprint"><code>var arraySubscriber = function( data ){
  $('.list').append('&lt;li&gt;&lt;h3&gt;' + topic + '&lt;/h3&gt;&lt;h4&gt;' + data + '&lt;/h4&gt;&lt;/li&gt;');
  var newsSubscription = $.subscribe( 'news/update', arraySubscriber );
};
</code></pre>

<a name="publish"></a>
<h2>$.publish</h2>
<p>The $.publish() method lets you send data to all topics that are subscribed to a topic.</p>

<pre class="prettyprint"><code>$.publish('news/update', 'The New York Stock Exchange rose an unprecedented 1000 points in just three minutes. Analysts and investors are confused and uncertain how to respond.');
</code></pre>

<a name="unsubscribe"></a>
<h2>$.unsubscribe</h2>
<p>After setting up a subscription to a topic, you may want to unsubscribe when certain conditions occur. You can do this with the $.unsubscribe() method. Just pass it the name to the subscription you set up, that would be one with a topic and callback as its arguments. See below:</p>

<pre class="prettyprint"><code>$.unsubscribe(newsSubscription);
</code></pre>
<p>After unsubscribing from a topic, any further attempts to publish data to the method will do nothing.</p>

<pre class="prettyprint"><code>var arraySubscriber = function(data) {
  $('.list').append('&lt;li&gt;&lt;h3&gt;' + topic + '&lt;/h3&gt;&lt;h4&gt;' + data + '&lt;/h4&gt;&lt;/li&gt;');
  var newsSubscription = $.subscribe('news/update', arraySubscriber);
};
// This news item gets published:
$.publish( 'news/update', 'The New York Stock Exchange rose an unprecedented 1000 points in just three minutes. Analysts and investors are confused and uncertain how to respond.' );
$.unsubscribe(newsSubscription);
// Due to being unsubscribed above, this does nothing:
$.publish('news/update', 'We have nothing further to comment at this time.');
</code></pre>

<a name="search"></a>
<h2>$.UISearch</h2>
<p>This method creates a search field at the top of the article styled appropriately for each OS. You pass in a object of options to setup the search field. This will prepend the search field to the article's section that you specified with the article ID, otherwise it will prepend it to the first article of your app.</p>
<pre class="prettyprint"><code>$.UISearch({
  articleId: '#products',
  id: 'productSearch',
  placeholder: 'Find a product',
  results: 5
});
</code></pre>

<a name="UISetupCarousel"></a>
<h2>$.UISetupCarousel</h2>
<p>This method creates a swipable carousel. It uses mouse gestures to enable desktop testing. It also adjusts direction automatically when the document direction is set to "rtl" for "right-to-left" alphabets (Arabic, Hebrew, Farsi, Urdu, etc.).</p>
<p>The carousel actually only has three panels, reducing the amount of memory it requires. As the user swipes, the widget updates the position and content of the panels on either side of the current panel. To initialze the carousel, you pass it an object of key-value parameters:</p>
<pre class="prettyprint"><code>var panels = [
  "&lt;h2&gt;Panel 1&lt;/h2&gt;&lt;h2&gt;&lt;/h2&gt;&lt;img src='../images/american-football.jpg'&gt;",
  "&lt;h2&gt;Panel 2&lt;/h2&gt;&lt;img src='../images/couple.jpg'&gt;",
  "&lt;h2&gt;Panel 3&lt;/h2&gt;&lt;img src='../images/daisy.jpg'&gt;",
  "&lt;h2&gt;Panel 4&lt;/h2&gt;&lt;img src='../images/dependent.jpg'&gt;",
  "&lt;h2&gt;Panel 5&lt;/h2&gt;&lt;img src='../images/dreamy.jpg'&gt;",
  "&lt;h2&gt;Panel 6&lt;/h2&gt;&lt;img src='../images/girl.jpg'&gt;",
  "&lt;h2&gt;Panel 7&lt;/h2&gt;&lt;img src='../images/lacrosse.jpg'&gt;",
  "&lt;h2&gt;Panel 8&lt;/h2&gt;&lt;img src='../images/hot-air-balloon.jpg'&gt;
]
{
  target: '#carousel',
  panels: panels,
  loop: true,
  pagination: true
}
</code></pre>
<p>The target is a wrapper div that will hold the carousel. The carousel itself is just and unordered list. Each list item will be a panel in the carousel. You provide content for the panels by passing in an array of markup as strings. As long as the markup is valid and can fit within the panel, it should be fine. If you intend to put more content than can fit in a panel, just style the list items for the carousel so that they are scrollable like this:</p>
<pre class="prettyprint"><code>.carousel-track > li {
  overflow-y: auto !important;
}
</code></pre>

<p>By default the carousel has its "loop" property set to cycle infinitely. If you want to make it only swipe between the first and last, but not past them, pass in a false vale for the loop attribute:</p>
<pre class="prettyprint"><code>{
  target: '#carousel',
  panels: panels,
  loop: false
}
</code></pre>

<p>Carousels can have pagination. By default they do not. You need to pass a pagination value of true:</p>
<pre class="prettyprint"><code>{
  target: '#carousel',
  panels: panels,
  loop: false,
  pagination: true
}
</code></pre>

<p>When pagination is set to true, a pagination indicator is output for each carousel panel. The user can navigate the carousel by tapping on the pagination indicators. Also, as the user swipes through the carousel, the appropriate pagination indicators will be highlighted. Please be aware that on a mobile device, if you have more than 18 paginations, it will be difficult for the user to accurately select one to navigate the carousel. Carousels work best with fifteen or less indicators.</p>

<p>When you initialize a carousel, it is a unique instance of $.UICarousel. This is stored on the carousel wrapper indicated by the target attribute in the setup function. You can retrieve the instance of the carousel like this (assuming we have a carousel wrapper with the id "myCarousel":</p>
<pre class="prettyprint"><code>var myCarousel = $('#myCarousel').data('carousel');
$('button').on('singletap', function() {
  // Go to panel number 6:
  myCarousel.goToPanel(5);
});
</code></pre>
<p>The dimensions of the carousel are controlled by CSS, so you can change the height and width to fit your needs. Please be aware that if you make a carousel too big for a mobile screen, the user may be in a situation where he or she cannot scroll vertically to see other content above or below the carousel. Test on various screen sizes to make sure the carousel doesn't prevent access to other content. You can always use media queries to change the size of the carousel based on the devices dimensions. To style the dimensions, just put the CSS directly in your application. You can use OS classes to target each operating system:</p>
<pre class="prettyprint"><code>.isAndroid .carousel {
  width: 240px;
  height: 320px;
}
.isiOS .carousel {
  width: 320px;
  height: 300px;
}
.isWindows .carousel {
  width: 320px;
  height: 300px;
}
</code></pre>

<a name="BindData" ></a>
<h2>$.BindData()</h2>
<p>As of version 3.7.0, ChocolateChip-UI offers a simple way to set up one-way data binding between from elements and static parts of the UI. This is done by the use of two attrbites: <code>data-controller</code> and <code>data-model</code>. You put <code>data-controller</code> on a form element, and <code>data-model</code> on the part of the UI where you want that value to be displayed. Both attributes need to have the same value so that ChocolateChip-UI can establish the relationship between them.</p>
<pre class='prettyprint'><code>&lt;ul class="list"&gt;
  &lt;li&gt;&lt;lable&gt;Enter data:&lt;/lable&gt; 
    &lt;input id='myText' data-controller='input-value' type='text'&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;h3 data-model='input-value'&gt;&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>To establish all of your data bindings, all you need to do is execute the following method at load time or at anyother time in your app's life cycle:</p>
<pre class='prettyprint'><code>$.UIBindData();
</code></pre>
<p>This method will then scan the document for data-controlers and data-models. When it finds matches, it automatically creates delegated events that publish broadcasts with data when their values change. Similarly, it automatically creates mediators that listen for those broadcasts and update their data-model targets when they are received. To learn about more complex data binding setups, please read the chapter: "Mediators, Pub/Sub and Data Binding".</p>

<script>
  (function() {
    prettyPrint();
  })();
</script>
<script>
	$(function() {
		$('body').scrollTop(0);
		prettyPrint();
		$('#documentation').trigger('click');
		$('#platformspecifics').addClass('selected');
	});
</script>