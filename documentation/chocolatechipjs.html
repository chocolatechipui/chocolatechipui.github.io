<h1>ChocolateChip.JS</h1>

<p>ChocolateChipJS is an optional library for use with ChocolateChip-UI. It is similar to jQuery, but it is not a drop in replacement. There are many differences between the two. ChocolateChipJS was built for mobile devices, not for desktop use. It's therefore small and fast, up to 30% faster than jQuery at doing typical DOM manipulations which you would do in an app. It is up to four times faster than Zeptojs at DOM manipulation. You will notice the speed difference when you switch from one library to the other. Interactions with ChocolateChipJS make your app feel as responsive as native ones. jQuery, on the other hand, may appear somewhat sluggish. Because most developers only know and care about jQuery, we've made it the default for ChocolateChip-UI. However, if performance is important to you and your experiencing some sluggish behavior with jQuery, consider trying ChocolateChipJS. It's not that different.</p>

<p>The <a target="_blank" href="https://github.com/chocolatechipui/ChocolateChipJS">ChocolateChipJS repository</a> is available on Github. You can download the sourcecode and build it yourself. Or you can just look inside the ChocolateChipJS folder inside the src folder of ChocolateChip-UI. It's already compiled and ready to use. To learn how to include it with the working examples for ChocolateChip-UI, please read the documentation <a href="./documentation#/building">Building</a>.</p>

<p>Let me repeat: ChocolateChipJS is not a drop in replacement for jQuery. If you have plugins or libraries that depend on jQuery, stick with jQuery. If you do not have any such jQuery dependencies and performance is a big deal for you, please look into using to ChocolateChipJS.</p>

<p>The first thing to be aware of with ChocolateChipJS is that it does not switch parameters around as jQuery does when looping over collections. ChocolateChipJS maintains the normal JavaScript order: context first, followed by the index.</p>

<pre class="prettyprint"><code>['one','two','three'].each(function(ctx, idx){
  // Access the context: 
    console.log(ctx)
  // Access the index:
    console.log(idx);
});

$('li').each(function(ctx, idx) {
  console.log(ctx.nodeName);
  $(ctx).css({'background-color':'red'});
  $(ctx).prepend(idx + ": ");
});
</code></pre>

<p>The reason for this is because all node collections that ChocolateChipJS returns are arrays. The <code>each</code> method is just an alias for the JavaScript <code>Array.prototype.forEach</code> method. Therefore, the parameter order is the same as the native JavaScript foreach method.</p>

<p>Another big difference from jQuery is that ChocolateChipJS always returns the node that matches a property check, whereas jQuery tends to return booleans. The following are some of the things you can do using ChocolateChipJS:</p>

<pre class="prettyprint"><code>// Returns the tag if it is a "button" tag:
$('.back').is('button').css({'background-color': 'red'});

// Returns the tag if it is not a list element:
$('button').isnt('li').css({'background-color': 'red'}); 

// Returns the ul tag it if has list items:
$('ul').has('li').css({'background-color': 'red'});

// Returns the ul if it does not have div children:
$('ul').hasnt('div').css({'background-color': 'red'});

// Returns the element if it has this class:
$('div').hasClass('silly').css({'background-color': 'red'});

// Returns the element if it has this attribute:
$('button').hasAttr('disabled').css({'background-color': 'red'});
</code></pre>

<p>By returning the element in these checks, ChocolateChipJS gives you immediate access to the element so you can do something with it. To accompish the same tasks with jQuery would require something like this:</p>

<p>jQuery:</p>

<pre class="prettyprint"><code>// Change background color if Div has class "attention":
$('div').each(function(idx, ctx) {
  if ($(ctx).hasClass('attention')) {
    $(ctx).css({'background-color': 'red'});
  }
});
</code></pre>

<p>ChocolateChipJS:</p>
<pre class="prettyprint"><code>// Change background color if Div has class "attention":
$('div').hasClass('attention').css({'background-color': 'red'});
</code></pre>

<p>If you need to get the equivalent of jQuery's boolean return, you can just check for a single element using the index value of 0:</p>

<pre class="prettyprint"><code>// Test if an element exists:
if ($('#main')[0]) {
  console.log('#main does exist!');
}

// Test if an element has descendants:
if ($('ul').has('li')[0]) {
  console.log('The list is not empty!');
}

// Test if element has a particular class:
if (('li').hasClass('comp')[0]) {
  console.log('This list item has the class "comp".');
} else {
  console.log('Empty!')
}
</code></pre>

<p>You can also check the length property on what they return:</p>

<pre class="prettyprint"><code>// Test if element has a particular class:
if (('li').hasClass('comp').length) {
  console.log('This list item has the class "comp".');
} else {
  console.log('Empty!')
}
</code></pre>

<p>If you have experience with jQuery, you will find ChocolateChipJS easy to learn. The following documentation outlines how ChocolateChipJS works. Read it carefully and you will be productive in a short time.</p>

<a name="dollar"></a>
<h2>$</h2>

<p>The $ sign is the basic method from which everything in ChocolateChip is created. It can take several different arguments. When the argument is a string selector, a string of markup, a DOM element, an array of elements or a node collection, ChocolateChip returns the result as an array. In the case of a selector, the array will contain all matches. In the case of markup, it will convert the markup into an array of nodes. In the case of a DOM node, it will be the sole item in the array. In the case of an array of elements, the array itself will be returned without modification. In the case of a node collection, it will be returned as an array of elements.</p>

<p>If you pass in a function as an argument, ChocolateChip will check to see if the DOMContentLoaded event has fired. If so, it will execute the function immediately, otherwise it will wait until the DOMContentLoaded event fires. By passing in an anonymous function, you can write code that will not execute until the DOM has been fully loaded, but before the page has been rendered to the screen. This allows you to make changes before the user sees anything.</p>

<pre class="prettyprint"><code>// Get all list items:
var listItems = $('li');

// Get the first article:
var main = $('#main');

// Get all lists:
var lists = $('.list');

// Create a button node:
var button = $('&lt;button&gt;Click&lt;/button&gt;');

// Get all elements with the class ".back":
var backButtons = $('.back');

// Returns the same array of back buttons:
var sameButtons = $(backButtons);

// Get all elements with this attribute:
var disabled = $('[disabled]');

// Get a node collection:
var listItems = document.querySelectorAll('li');

// Return the collection as an array:
var li = $(listItems);

$(function() {
  // Execute code here.
  console.log('The document is loaded.);
});
</code></pre>

<a name="window"></a>
<p><strong>window</strong></p>

<p>The window object is not like DOM nodes. It cannot be manipulated. As such, the $ method will not expose it to you if you provide it as a selector. Instead, to prevent collection methods from throwing exceptions, it will return an empty array:

<pre class="prettyprint"><code>var w = $(window) // returns [];
w.css('width'); // returns undefined;
w.css('width','1000px') // returns [];
</code></pre>

<p>To get window properties, access the window object directly:</p>

<pre class="prettyprint"><code>var windowWidth = window.innerWidth;
var windowHeight = window.innerHeight;
</code></pre>

<a name="window_resize"></a>
<p><strong>window.resize</strong></p>

<p>You might find yourself in a position where you want to track the window resize event while testing on the desktop. For mobile devices there is the onorientationchange event. To attach an onresize event to the winow, do the following:</p>

<pre class="prettyprint"><code>window.onresize = function() {
  // Do whatever you need to when the window resizes.
  // Check window.innerWidth or window.innerHeight.
  // Do some math comparisons...
};
</code></pre>


<a name="extend"></a>
<h2>$.extend</h2>

<p>ChocolateChipJS uses the <code>$.extend</code> method to extend objects and functions. You can use it to override or extend an existing object. It expects two arguments:</p>

<ol>
<li>The object to extend</li>
<li>The object to extend with</li>
</ol>

<pre class="prettyprint"><code>var myObj = {
  name: "Wobba"
}
</code></pre>

<p>To extend the above object we can do this:</p>

<pre class="prettyprint"><code>$.extend(myObj, {
  age: 100,
  job: 'rocket scientist'
  employed: true
});

/* 
This will make myObj equal:
{
  name: "Wobba",
  age: 100,
  job: 'rocket scientist'
  employed: true
}
*/
</code></pre>

<p>If you only pass in the object to extend with, ChocolateChipJS will assume you want to extned its $:</p>

<pre class="prettyprint"><code>$({
  myFunc : function(msg) {
    console.log('This is the message: ' + msg);
  }
});

//Now you can do:
$.myFunc('This is the message.');
</code></pre>

<p>ChocolateChipJS also offer <code>$.fn.extend</code>. This allows you to extned the collection object so that you can add new methods to loopable arrays, particularly node elements. This version takes one argument, the property or properties to add to the <code>$.fn</code> object. Because this extend the collection object, you should always check the length of the object and return and empty array if it has no length or there are no arguments. Because this is a colleciton, we need to loop over the items to act on them. After doing whatever it is we want to do with the items in the collection, we return the collection using the keyword <code>this</code>.</p>

<pre class="prettyprint"><code>$.fn.extend({
  changeTextColor: function(color) {
    if (!this.length || !arg) return [];
    this.each(function(node) {
      node.style.color = color;
    }
    return this;
  }
});
</code></pre>

<p>We can now do:</p>

<pre class="prettyprint"><code>$(h1).changeTextColor('red');
</code></pre>

<h2>
<a name="cc-traversing-the-dom" class="anchor" href="#traversing-the-dom" aria-hidden="true"><span class="octicon octicon-link"></span></a>Traversing the DOM</h2>

<p>ChocolateChipJS has a number of functions to traverse the DOM to access nodes.</p>

<ul>
<li>$()</li>
<li>$(selector).find()</li>
<li>$(collection).each()</li>
<li>$(selector).prev()</li>
<li>$(selector).next()</li>
<li>$(selector).first()</li>
<li>$(selector).last()</li>
<li>$(selector).children()</li>
<li>$(selector).parent()</li>
<li>$(selector).ancestor()</li>
<li>$(selector).closest()</li>
<li>$(selector).siblings()</li>
<li>$(selector).unique()</li>
<li>$(selector).eq()</li>
<li>$(selector).index()</li>
<li>$(selector).is()</li>
<li>$(selector).isnt()</li>
<li>$(selector).has()</li>
<li>$(selector).hasnt()</li>
<li>$(selector).hasClass()</li>
<li>$(selector).hasAttr()</li>
</ul><h3>
<a name="cc-$" class="anchor" href="#" aria-hidden="true"><span class="octicon octicon-link"></span></a>$()</h3>

<p>The dollar sign is primarily used to get a node or set of nodes in your document. You pass it a selector, it returns you what it found. If it found nothing, it will return an empty array. You can always test if a node was returned by testing the result's length:</p>

<pre class="prettyprint"><code>var elem = $('.someElement');
if (elem.length) {
  console.log('Found the element!');
} else {
  console.log("Didn't find anything.")
}
</code></pre>

<p>Selectors can be any valid CSS selectors:</p>

<pre class="prettyprint"><code>$('ul') // tag
$('#list') // id
$('.list') // class
$('[checked]') // attribute
$('li:first-child') // pseudo-class
$('ul + p') // adjacent selector
</code></pre>

<h3>
<a name="cc-find" class="anchor" href="#find" aria-hidden="true"><span class="octicon octicon-link"></span></a>find</h3>

<p>The <code>find</code> method allows you to search for an element using another as the starting point. This can save you time in finding an element since the route will be shorter. </p>

<p>$('ul').find('a') // Find A tags inside of UL's LIs</p>

<p>The <code>find</code> method works like the dollar sign, accepting the same selector arguments.</p>

<h3>
<a name="cc-each" class="anchor" href="#each" aria-hidden="true"><span class="octicon octicon-link"></span></a>each</h3>

<p>The <code>each</code> method allows you to iterate over the collection returned by the dollar sign or find methods. Be aware that this uses the same parameter order as the JavaScript Array forEach method: context followed by index. This is the opposite order adopted by jQuery.</p>

<pre class="prettyprint"><code>$('li').each(function(ctx, idx) {
  $(ctx).css('color', 'red');
  console.log('Item number: ' + idx);
});
</code></pre>

<p>In jQuery the parameter order would be reversed:</p>

<pre class="prettyprint"><code>$('li').each(function(idx, ctx) {
  $(ctx).css('color', 'red');
  console.log('Item number: ' + idx);
});
</code></pre>

<p>We not sure why John Resig chose to reverse the default order. ChocolateChipJS follows the normal order that JavaScript uses, so if you're used to jQuery's order, watch out for that.</p>

<p>The last parameter is optional, so if you just want to access a node and do something, you can code like this:</p>

<pre class="prettyprint"><code>$('li').each(function(ctx) {
  $(ctx).css('color', 'red');
});
</code></pre>

<h3>
<a name="cc-prev" class="anchor" href="#prev" aria-hidden="true"><span class="octicon octicon-link"></span></a>prev</h3>

<p>The method <code>prev</code> will return the previous sibling node. </p>

<p>Markup:</p>

<pre class="prettyprint"><code>&lt;p&gt;Some text&lt;/p&gt;
&lt;p id="message"&gt;More text here&lt;/p&gt;
</code></pre>

<p>Script:</p>

<pre class="prettyprint"><code>// Make the tag before color red:
$('#message').prev().css('color','red');
</code></pre>

<h3>
<a name="cc-next" class="anchor" href="#next" aria-hidden="true"><span class="octicon octicon-link"></span></a>next</h3>

<p>The method <code>next</code> with return the next sibling node.</p>

<p>Markup:</p>

<pre class="prettyprint"><code>&lt;p id="message"&gt;More text here&lt;/p&gt;
&lt;p&gt;Some text&lt;/p&gt;
</code></pre>

<p>Script:</p>

<pre class="prettyprint"><code>// Make the tag after color red:
$('#message').next().css('color','red');
</code></pre>

<h3>
<a name="cc-first" class="anchor" href="#first" aria-hidden="true"><span class="octicon octicon-link"></span></a>first</h3>

<p>This method returns the first child element of a node.</p>

<p>Markup:</p>

<pre class="prettyprint"><code>&lt;ul&gt;
  &lt;li&gt;One&lt;/li&gt;
  &lt;li&gt;Two&lt;/li&gt;
  &lt;li&gt;Three&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>Script:</p>

<pre class="prettyprint"><code>// Make the first list item red:
$('ul').first().css('color','red')
</code></pre>

<h3>
<a name="cc-last" class="anchor" href="#last" aria-hidden="true"><span class="octicon octicon-link"></span></a>last</h3>

<p>This method returns the last child element of a node.</p>

<p>Markup:</p>

<pre class="prettyprint"><code>&lt;ul&gt;
  &lt;li&gt;One&lt;/li&gt;
  &lt;li&gt;Two&lt;/li&gt;
  &lt;li&gt;Three&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>Script:</p>

<pre class="prettyprint"><code>// Make the last list item red:
$('ul').last().css('color','red')
</code></pre>

<h3>
<a name="cc-children" class="anchor" href="#children" aria-hidden="true"><span class="octicon octicon-link"></span></a>children</h3>

<p>This method returns the child nodes of an element. If no selector is provided, it returns all child nodes, otherwise it returns the child nodes that match the selector.</p>

<pre class="prettyprint"><code>// Make all list items blue:
$('ul').children().css('color', 'blue');

// Make selected list items red:
$('ul').children('.selected').css('color', 'red');
</code></pre>

<p>You can also provide a selector as an argument. In that case, <code>[].children(selector)</code> will return all children that match the selector. If there are none, the result will be undefined.</p>


<pre class="prettyprint"><code>// Find all children that are paragraphs and color their text red:
$('#main).children('p').css('color','red')
</code></pre>

<h3>
<a name="cc-parent" class="anchor" href="#parent" aria-hidden="true"><span class="octicon octicon-link"></span></a>parent</h3>

<p>This method returns the parent of an element.</p>

<p>Markup:</p>

<pre class="prettyprint"><code>&lt;ul&gt;
  &lt;li&gt;One&lt;/li&gt;
  &lt;li&gt;Two&lt;/li&gt;
  &lt;li&gt;Three&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>Script:</p>

<pre class="prettyprint"><code>// Put red border on list items parent:
$('li').parent().css('border','solid 1px red');
</code></pre>

<h3>
<a name="cc-ancestor" class="anchor" href="#ancestor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ancestor</h3>

<p>This method returns the matching anchestor of an element. This will be the first ancestor matching the selector.</p>

<pre class="prettyprint"><code>// Get the id of the ancestor article:
$('ul').ancestor('article')[0].id
</code></pre>

<h3>
<a name="cc-closest" class="anchor" href="#closest" aria-hidden="true"><span class="octicon octicon-link"></span></a>closest</h3>

<p>This method is an alias for <code>ancestor</code> for people used to the jQuery method of the same name.</p>

<h3>
<a name="cc-siblings" class="anchor" href="#siblings" aria-hidden="true"><span class="octicon octicon-link"></span></a>siblings</h3>

<p>This method returns the siblings of an element. If no arguments are passed, it will return all siblings. If a selector is supplied, it will return siblings that match the selector.</p>

<pre class="prettyprint"><code>// Turn unselected list items blue:
$('li.selected').siblings().css('color','blue');


// Set all divs that are siblings of a paragraph
// to have red borders:
$('p').siblings('div').css('border', 'solid 1px red');
</code></pre>

<h3>
<a name="cc-unique" class="anchor" href="#unique" aria-hidden="true"><span class="octicon octicon-link"></span></a>unique</h3>

<p>This method returns an array or collection of nodes without any duplicates. </p>

<pre class="prettyprint"><code>// Returns [1,2,3,4,5]
[1,2,2,2,3,3,4,5,5,5,5].unique();
</code></pre>

<h3>
<a name="cc-eq" class="anchor" href="#eq" aria-hidden="true"><span class="octicon octicon-link"></span></a>eq</h3>

<p>This method is used on a collection to pluck out the node at the position indicated by the argument. It takes a zero-based integer. So 0 would get the first node, 1, the second, etc. By passing a negative number, you can pluck a node starting from the end of the collection. So -1 would be the last, -2, the next to last, etc.</p>

<pre class="prettyprint"><code>$('li').eq(0); // get the first list item
$('li').eq(3); // get the fourth list item
$('li').eq('-1'); // get the last list item
$('li').eq('-2'); // get the next to last list itme
</code></pre>

<h3>
<a name="cc-index" class="anchor" href="#index" aria-hidden="true"><span class="octicon octicon-link"></span></a>index</h3>

<p>This method will return the index of the element. This is zero-based, so and index value of 0 would be indicate the elements was the first, 1 would be the second, etc.</p>

<p>Markup:</p>

<pre class="prettyprint"><code>&lt;ul&gt;
  &lt;li&gt;One&lt;/li&gt;
  &lt;li&gt;Two&lt;/li&gt;
  &lt;li class='selected'&gt;Three&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<pre class="prettyprint"><code>$('.selected').index(); // returns 2
</code></pre>

<h3>
<a name="cc-is" class="anchor" href="#is" aria-hidden="true"><span class="octicon octicon-link"></span></a>is</h3>

<p>This method will return the element that matches the condition provided as an argument. You can use any valid CSS selector, or a DOM node. Please note that this is not the same behavior as the jQuery function of the same name. jQuery only returns a boolean for each element, not the element.</p>

<pre class="prettyprint"><code>// Only list items with a class of 'selected' will be red:
$('li').is('.selected').css('color','red');

// This is equivalent to the following in jQuery:
$('li').each(function(idx, ctx) {
  if ( $(ctx).is('.selected')) {
    $(ctx).css('color','red');
  }
});
</code></pre>

<h3>
<a name="cc-isnt" class="anchor" href="#isnt" aria-hidden="true"><span class="octicon octicon-link"></span></a>isnt</h3>

<p>This method will return the element that does not match the condition provided as an argument. You can use any valid CSS selector, or a DOM node.</p>

<pre class="prettyprint"><code>// Only list items that do not have a class of selected will be green:
$('li').isnt('.selected').css('color','green');
</code></pre>

<h3>
<a name="cc-has" class="anchor" href="#has" aria-hidden="true"><span class="octicon octicon-link"></span></a>has</h3>

<p>This method returns all elements whose descendent matches the selector. You can use any valid CSS selector, or a DOM node.</p>

<pre class="prettyprint"><code> // Add class 'nav' to li items with aside:
$('li').has('aside').addClass('nav');
</code></pre>

<h3>
<a name="cc-hasnt" class="anchor" href="#hasnt" aria-hidden="true"><span class="octicon octicon-link"></span></a>hasnt</h3>

<p>This method returns all elements that do not match the selector. You can use any valid CSS selector, or a DOM node.</p>

<pre class="prettyprint"><code> // Add class empty to all list items without an h3:
$('li).hasnt('h3').addClass('empty');
</code></pre>

<h3>
<a name="cc-hasclass" class="anchor" href="#hasclass" aria-hidden="true"><span class="octicon octicon-link"></span></a>hasClass</h3>

<p>This method will return all elements that have the provided class.</p>

<pre class="prettyprint"><code> // Append to all list items with the class 'show-detail':
$('li').hasClass('show-detail').append('Gonna show something');
</code></pre>

<p>If you want to do a boolean test for the presence of a class, you can check to see if an element was returned. You can do that by reduce the array to a single element using the [0] index:</p>

<pre class="prettyprint"><code>$('li').each(function(ctx, idx) {
   if ($(ctx).hasClass('show-detail')[0]) {
     // do something if it has the class
   } else {
     // Do something else.
   }
});
</code></pre>

<p>Or you could just slip down into normal ECMAScript 5 mode:</p>

<pre class="prettyprint"><code>$('li').each(function(ctx, idx) {
   if (ctx.classList.contains('show-detail')) {
     // do something if it has the class
   } else {
     // Do something else.
   }
});
</code></pre>

<h3>
<a name="cc-hasattr" class="anchor" href="#hasattr" aria-hidden="true"><span class="octicon octicon-link"></span></a>hasAttr</h3>

<p>This method will return the elements if they have the provided attribute.</p>

<pre class="prettyprint"><code>// Append 'classified' to all list items with a class attribute:
$('li').hasAttr('class').append('classified');
</code></pre>

<h2>
<a name="cc-manipulating-the-dom" class="anchor" href="#manipulating-the-dom" aria-hidden="true"><span class="octicon octicon-link"></span></a>Manipulating the DOM</h2>

<p>ChocolateChipJS has a number of methods that allow you to manipulate the DOM in various ways.</p>

<ul>
<li>$.make(String)</li>
<li>$()</li>
<li>$.html(String)</li>
<li>$(selector).html(String)</li>
<li>$(selector).css(style)</li>
<li>$(selector).attr()</li>
<li>$(selector).removeAttr()</li>
<li>$(selector).hasAttr()</li>
<li>$(selector).prop()</li>
<li>$(selector).addClass()</li>
<li>$(selector).removeClass()</li>
<li>$(selector).toggleClass()</li>
<li>$(selector).hasClass()</li>
<li>$(selector).dataset()</li>
<li>$(selector).data()</li>
<li>$(selector).removeData()</li>
<li>$(selector).val()</li>
<li>$(selector).enable()</li>
<li>$(selector).disable()</li>
<li>$(selector).show()</li>
<li>$(selector).hide()</li>
<li>$(selector).before()</li>
<li>$(selector).after()</li>
<li>$(selector).prepend()</li>
<li>$(selector).append()</li>
<li>$(selector).prependTo()</li>
<li>$(selector).appendTo()</li>
<li>$(selector).insert()</li>
<li>$(selector).clone()</li>
<li>$(selector).wrap()</li>
<li>$(selector).unwrap()</li>
<li>$(selector).remove()</li>
<li>$(selector).empty()</li>
<li>$.replace()</li>
</ul><h3>
<a name="cc-make" class="anchor" href="#make" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.make</h3>

<p>This method will attempt to construct DOM nodes from the markup passed to it. The markup must be valid or the method will throw an exception. The nodes are returned in an array, so you can use any of ChocolateChipJS's collection methods.</p>

<pre class="prettyprint"><code>// Create and empty list:
   var list = $.make('&lt;ul class="list"&gt;&lt;/ul&gt;');
   list.innerHTML =
   $.make('&lt;li&gt;&lt;h3&gt;One&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Two&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;Three&lt;/h3&gt;&lt;/li&gt;');
</code></pre>

<h3>
<a name="cc-$-2" class="anchor" href="#-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>$()</h3>

<p>This method, although generally used for finding a DOM node with a selector, can also be used to create DOM nodes. Pass it a string of valid markup and it will return nodes, just like <code>$.make</code>.</p>

<pre class="prettyprint"><code>var button = $('&lt;button&gt;Click&lt;/button&gt;');
</code></pre>

<h3>
<a name="cc-html" class="anchor" href="#html" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.html</h3>

<p>This method is an alias for <code>$.make</code>. Pass it a string of valid markup and it will return an array of nodes.</p>

<pre class="prettyprint"><code>var button = $.html('&lt;button&gt;Click&lt;/button&gt;');
</code></pre>

<h3>
<a name="cc-html-2" class="anchor" href="#html-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>$().html</h3>

<p>Unlike <code>$.html</code>, which creates nodes, this method will replace the contents of the target element(s) with the content provided. If no argument is provided, it will return the contents of the element, including nodes. If a string is provided as an argument, that string will replace the contents of the element. If the string is markup, it will be converted to nodes before inserting. If the string is empty (''), then the contents of the element will be replaced with an empty text node.</p>

<pre class="prettyprint"><code>// Get all the items in the menu:
var contents = $('#menu').html();

// Empty the first item in the list:
$('li').eq(0).html('');

// Replace the content of all list items with text:
$('li').html('New Text Here!');

// Replace the content of all list items with new markup:
$('li').html('&lt;h2&gt;New List Title&lt;/h2&gt;');
</code></pre>

<h3>
<a name="cc-css" class="anchor" href="#css" aria-hidden="true"><span class="octicon octicon-link"></span></a>css</h3>

<p>This method allows you to set or retrieve the style of an element. It can accept to arguments: property and value. If no value is passed, the method attempts to retrieve the the CSS property of the first element matching the selector. If a property and value are provided, it will loop through all matching selectors applying that style. When passing property/value pairs, if it is a single pair, you can just pass them in as quoted strings separated by a comma. For more arguments, pass in a object literal defining the styles to apply. If you want the width or height of an element, use the $(selector).width() or $(selector).height() methods, as these return the values as straight integers with length identified. Otherwise, using $(selector).css('width'), etc., you'll need to pass the returned value through the parseInt method. See the examples below:</p>

<pre class="prettyprint"><code>// Get the height of the first list item.
// returns the height with lent identifier: 100px
var height = $('li').css('height');

// Get the height of the third list item:
var height = $('li').eq(2).css('height');

// Get the body background color:
var backgroundColor = $.body.css('background-color');

// Set the background color on all list items:
$('li').css('background-color': 'gold');

// Set multiple properties on all list items:
$('li').css({'background-color': 'orange', 'color': 'red', 'font-weight': 'bold'});
</code></pre>

<p>When getting the CSS property of an element, it is not possible to chain any methods, as the value returned is the CSS, not the element. When apply styles, the elements are always returned, allowing you to chain other collection methods.</p>

<pre class="prettyprint"><code>// Will throw and exception:
 $('li').css('height').append('Modified!');

 // This is chainable:
 $('li').css('height', '40px').append('Modified!');
</code></pre>

<h3>
<a name="cc-attr" class="anchor" href="#attr" aria-hidden="true"><span class="octicon octicon-link"></span></a>attr</h3>

<p>This method gets or sets the attribute of elements. If only an attribute is provided, it will return the attribute value of the first element in the collection. If an attribute and value are provided, they will be set on all elements in the array.</p>

<pre class="prettyprint"><code>// Get the checked state of the input in the first list item.
// (true or false): 
var checked = $('li').find('input').attr('checked'); 

// Set the checked state: 
var checked = $('li').eq(0).find('input').attr('checked', 'checked');

// Set the aria role of all buttons: 
$('button').attr('role', 'button');
</code></pre>

<h3>
<a name="cc-removeattr" class="anchor" href="#removeattr" aria-hidden="true"><span class="octicon octicon-link"></span></a>removeAttr</h3>

<p>This method will remove the provided attribute from the elements while retuning the elements.</p>

<pre class="prettyprint"><code>// Remove the attribute 'class' and color the list item red:
$('li').removeAttr('class').css('color','red');
</code></pre>

<h3>
<a name="cc-hasattr-2" class="anchor" href="#hasattr-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>hasAttr</h3>

<p>This method will return all elements that have the provided class.</p>

<pre class="prettyprint"><code> // Append to all list items with the class 'show-detail':
$('li').hasClass('show-detail').append('Gonna show something');
</code></pre>

<p>If you want to do a boolean test for the presence of a class, you can check to see if an element was returned. You can do that by reduce the array to a single element using the [0] index:</p>

<pre class="prettyprint"><code>$('li').each(function(ctx, idx) {
   if ($(ctx).hasClass('show-detail')[0]) {
     // do something if it has the class
   } else {
     // Do something else.
   }
});
</code></pre>

<h3>
<a name="cc-prop" class="anchor" href="#prop" aria-hidden="true"><span class="octicon octicon-link"></span></a>prop</h3>

<p>This is the same as the attr method described above.</p>

<h3>
<a name="cc-addclass" class="anchor" href="#addclass" aria-hidden="true"><span class="octicon octicon-link"></span></a>addClass</h3>

<p>This method will add the provided class to every element in the array.</p>

<pre class="prettyprint"><code>// Add the class 'nav' to every list item:
$('li').addClass('nav');
</code></pre>

<h3>
<a name="cc-removeclass" class="anchor" href="#removeclass" aria-hidden="true"><span class="octicon octicon-link"></span></a>removeClass</h3>

<p>This method will remove the class from every element in the array.</p>

<pre class="prettyprint"><code>// Remove the class 'nav' from every list item:
$('li').removeClass('nav');
</code></pre>

<h3>
<a name="cc-toggleclass" class="anchor" href="#toggleclass" aria-hidden="true"><span class="octicon octicon-link"></span></a>toggleClass</h3>

<p>This method will toggle the class on all elements in the array. If the provided class is already present on an element, it will be removed. And if it is not on an element, it will be added.</p>

<pre class="prettyprint"><code>// Toggle the class 'purchased' on all list items. 
// All items that already have that class will have it removed, 
// while all items that do not have it, will have it added: 

$('li').toggleClass('purchased');
</code></pre>

<h3>
<a name="cc-hasclass-2" class="anchor" href="#hasclass-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>hasClass</h3>

<p>This method will return all elements that have the provided class.</p>

<pre class="prettyprint"><code> // Append to all list items with the class 'show-detail':
$('li').hasClass('show-detail').append('Gonna show something');
</code></pre>

<p>If you want to do a boolean test for the presence of a class, you can check to see if an element was returned. You can do that by reduce the array to a single element using the [0] index:</p>

<pre class="prettyprint"><code>$('li').each(function(ctx, idx) {
   if ($(ctx).hasClass('show-detail')[0]) {
     // do something if it has the class
   } else {
     // Do something else.
   }
});
</code></pre>

<h3>
<a name="cc-dataset" class="anchor" href="#dataset" aria-hidden="true"><span class="octicon octicon-link"></span></a>dataset</h3>

<p>This method is used to get or set HTML5 data attributes on elements. You provide two arguments for setting a value: the attribute name and the value for it. The attribute provided will automatically have 'data-' prepended to it, so you just provide the name for the attribute and the value it should hold. The value must be a string. You could store not string data by converting it to a string. However, ChocolateChipJS provides a more efficient way to do this using the data method, which allows you to cache data objects in relation to an element.</p>

<p>To retrieve a dataset, just provide the name of the attribute as an argument.</p>

<pre class="prettyprint"><code>// Set a data attribute.
// This will attrach the attribute like so: data-price='$2.00'.
$('li').eq(0).dataset('price', '$2.00');

// Get the data attribute:
var price = $('li').eq(0).dataset('price');

// Set the data attribute on all list items:
$('li').dataset('availability', 'in-stock');
</code></pre>

<p>When getting the data attribute on an array of elements, this method will return the value of the first element only:</p>

<pre class="prettyprint"><code>var value = $('li').dataset('availability');
// This is the same as:
var value = $('li').eq(0).dataset('availability');
</code></pre>

<h3>
<a name="cc-data" class="anchor" href="#data" aria-hidden="true"><span class="octicon octicon-link"></span></a>data</h3>

<p>This method will get and set data in relation to an element. Unlike the HTML5 data attribue, nothing is stored on the element. Instead the data is stored in a cache and tied to the element through its id. If the element has no id at the time the data is bound, the element is given a unique id to identify it in the cache.</p>

<pre class="prettyprint"><code>$('li').on('singletap', function() { 
  // Store the list item title in the list's data cache: 
  $(this).parent().data('selectedItem', $(this).find(h3).text());
});
</code></pre>

<h3>
<a name="cc-removedata" class="anchor" href="#removedata" aria-hidden="true"><span class="octicon octicon-link"></span></a>removeData</h3>

<p>This method will remove all stored data associated with an element.</p>

<pre class="prettyprint"><code>// Remove data with the key "selected":
$('#myList').removeData("selected");

// Remove all data associated with the list:
$('#myList').removeData();
</code></pre>

<h3>
<a name="cc-val" class="anchor" href="#val" aria-hidden="true"><span class="octicon octicon-link"></span></a>val</h3>

<p>This method will get or set the value of a form element. If no value is provided, it will return the element's value. If a value is provided, it will set that on the form element. When getting the value of an array of elements, this method will only return the value of the first element.</p>

<pre class="prettyprint"><code>// Set the value of the input:
$('input[type=email]').val('me@me.com');
// Set the value of all text input to 'Empty!':
$('input[type=text]').val('Empty!');
</code></pre>

<pre class="prettyprint"><code>// Get the value of the first text input:
var value = $('input[type=text]').val();
// or:
var value = $('input[type=text]').eq(0).val();
</code></pre>

<h3>
<a name="cc-enable" class="anchor" href="#enable" aria-hidden="true"><span class="octicon octicon-link"></span></a>enable</h3>

<p>This method will remove any disabled attributes added by the disable method or from other user interaction.</p>

<pre class="prettyprint"><code>$('button').enable();
</code></pre>

<h3>
<a name="cc-disable" class="anchor" href="#disable" aria-hidden="true"><span class="octicon octicon-link"></span></a>disable</h3>

<p>This will set the disabled state on all elements in the array. It does this by adding the class 'disabled' to the element, the attribute 'disabled="true"', and the style 'cursor: default' so that there is no hover state for the element.</p>

<pre class="prettyprint"><code>$('button').disable();
</code></pre>

<h3>
<a name="cc-show" class="anchor" href="#show" aria-hidden="true"><span class="octicon octicon-link"></span></a>show</h3>

<p>This method will perform an animated show of the target elements. You can pass it the arguments 'fast' or 'slow', or an integer representing the speed in milliseconds. You optionally include a callback to execute when the animation is complete. The keyword 'this' will refer to the element being shown. If no argument is passed, the elements are shown immediately without any animation.</p>

<pre class="prettyprint"><code>$('li').show('slow');
$('li').show('fast');
$('li').show(5000);
// Hide the elements and add the attribute hidden='totally':
$('li').show('fast', function() {
    $(this).attr('data-visible', 'totally');
});
$('li').show();
</code></pre>

<h3>
<a name="cc-hide" class="anchor" href="#hide" aria-hidden="true"><span class="octicon octicon-link"></span></a>hide</h3>

<p>This method will perform an animated hide of the target elements. You can pass it the arguments 'fast' or 'slow', or an integer representing the speed in milliseconds. You optionally include a callback to execute when the animation is complete. The keyword 'this' will refer to the element being hidden. If no argument is passed, the elements are hidden immediately without any animation.</p>

<pre class="prettyprint"><code>$('li').hide('slow');
$('li').hide('fast');
$('li').hide(5000);
// Hide the elements and add the attribute hidden='totally':
$('li').hide('fast', function() {
    $(this).attr('hidden', 'totally');
});
$('li').hide();
</code></pre>

<h3>
<a name="cc-before" class="anchor" href="#before" aria-hidden="true"><span class="octicon octicon-link"></span></a>before</h3>

<p>This method will insert the provided content before the element upon which this method is executed. It can accept a node, an array of elements, or a string of markup.</p>

<p>When providing a string of markup, it will be created and inserted before each element. In the case of a DOM element or array of elements, it will only be inserted before the last element in the collection. This is because the nodes already exist in memory, so there is only one copy of them to insert.</p>

<pre class="prettyprint"><code>// Insert before first list item:
$('li').eq(0).before('&lt;li&gt;New list item!&lt;/li&gt;');

// Insert before every list itme:
$('li').before('&lt;li&gt;New list item!&lt;/li&gt;');

var newListItems = $.make('&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;');
// Insert new list items before first list item:
$('li').eq(0).before(newListItems);

// Insert new list items before last list item:
$('li").before(newListItems);
</code></pre>

<h3>
<a name="cc-after" class="anchor" href="#after" aria-hidden="true"><span class="octicon octicon-link"></span></a>after</h3>

<p>This method will insert the provided content before the element upon which this method is executed. It can accept a node, an array of elements, or a string of markup.</p>

<p>When providing a string of markup, it will be created and inserted after each element. In the case of a DOM element or array of elements, it will only be inserted after the last element in the collection. This is because the nodes already exist in memory, so there is only one copy of them to insert.</p>

<pre class="prettyprint"><code>// Insert after first list item:
$('li').eq(0).after('&lt;li&gt;New list item!&lt;/li&gt;');

// Insert before every list itme:
$('li').after('&lt;li&gt;New list item!&lt;/li&gt;');

var newListItems = $.make('&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;');
// Insert new list items after first list item:
$('li').eq(0).after(newListItems);

// Insert new list items after last list item:
$('li").after(newListItems);
</code></pre>

<h3>
<a name="cc-prepend" class="anchor" href="#prepend" aria-hidden="true"><span class="octicon octicon-link"></span></a>prepend</h3>

<p>This method will prepend the provided argument to the target element. If a string of text is provided, it will be prepended as a text node. If a string of markup is provided, it will be prepended as nodes. If an array of nodes are provided, they will be prepended in order.</p>

<pre class="prettyprint"><code>// Prepend the text "Attention:":
$('h1').prepend('Attention: ');

// Prepend a new list item:
$('ul').prepend('&lt;li&gt;First Item&lt;/li&gt;');
</code></pre>

<h3>
<a name="cc-append" class="anchor" href="#append" aria-hidden="true"><span class="octicon octicon-link"></span></a>append</h3>

<p>This method will append the provided argument to the target element. If a string of text is provided, it will be appended as a text node. If a string of markup is provided, it will be appended as nodes. If an array of nodes are provided, they will be appended in order.</p>

<pre class="prettyprint"><code>// Append the text ", etc.":
$('h1').append(', etc.');

// Append a new list item:
$('ul').append('&lt;li&gt;Last Item&lt;/li&gt;');
</code></pre>

<h3>
<a name="cc-prependto" class="anchor" href="#prependto" aria-hidden="true"><span class="octicon octicon-link"></span></a>prependTo</h3>

<p>This method will prepend the elements it is executed on to the selector provided as an argument. In the case of elements in the document, this will remove them from their current position and prepend them to the target element. If the elements are created in memory and not yet present in the document, they will simply be prepended to the target element.</p>

<pre class="prettyprint"><code>// Remove all selected list items and
// prepend them to the selected items element:
$('li.selected').prependTo('#selectedItems');

// Prepend the new elements to #menu:
$.make('&lt;li&gt;Movies&lt;/li&gt;&lt;li&gt;Songs&lt;/li&gt;&lt;li&gt;Pictures&lt;/li&gt;').prependTo('#menu');
</code></pre>

<h3>
<a name="cc-appendto" class="anchor" href="#appendto" aria-hidden="true"><span class="octicon octicon-link"></span></a>appendTo</h3>

<p>This method will append the elements it is executed on to the selector provided as an argument. In the case of elements in the document, this will remove them from their current position and append them to the target element. If the elements are created in memory and not yet present in the document, they will simply be appended to the target element.</p>

<pre class="prettyprint"><code> // Remove all selected list items and
 // append them to the selected items element:
$('li.selected').appendTo('#selectedItems');

// Append the new elements to #menu:
$.make('&lt;li&gt;Movies&lt;/li&gt;&lt;li&gt;Songs&lt;/li&gt;&lt;li&gt;Pictures&lt;/li&gt;').appendTo('#menu');
// or:
$('&lt;li&gt;Movies&lt;/li&gt;&lt;li&gt;Songs&lt;/li&gt;&lt;li&gt;Pictures&lt;/li&gt;').appendTo('#menu');
</code></pre>

<h3>
<a name="cc-insert" class="anchor" href="#insert" aria-hidden="true"><span class="octicon octicon-link"></span></a>insert</h3>

<p>This method allows you to insert content at a particular position in an element's collection of child nodes. Although there are methods to append or prepend an element, there is no straightforward way to insert something at position 5, etc. This method provides that functionality. It takes two parameters: the content to insert, and the position. If no position is supplied, the content is appended at the end of the container. If the container has no child elements, then, regardless of the position supplied, the content will simply be inserted as the first child of the element.</p>

<p>Position positions are 'first' or 'last' for appending to these position, or an integer value. This is one-based, so the first position will be 1, the second: 2, the third: 3, etc.</p>

<pre class="prettyprint"><code>// Insert as last child of list item:
$('li').eq(2).insert('&lt;aside&gt;&lt;span class="nav"&gt;&lt;/span&gt;&lt;/aside&gt;', 'last');
// or:
$('li').eq(2).insert('&lt;aside&gt;&lt;span class="nav"&gt;&lt;/span&gt;&lt;/aside&gt;', 'last');

// Insert as first child of list item:
$('li').eq(2).insert('&lt;aside&gt;&lt;span class="nav"&gt;&lt;/span&gt;&lt;/aside&gt;', 'first');
// or:
$('li').eq(2).insert('&lt;aside&gt;&lt;span class="nav"&gt;&lt;/span&gt;&lt;/aside&gt;', 1);

// Insert as second child of list item:
$('li').eq(2).insert('&lt;aside&gt;&lt;span class="nav"&gt;&lt;/span&gt;&lt;/aside&gt;', 2);

// Insert as third child of list item:
$('li').eq(2).insert('&lt;aside&gt;&lt;span class="nav"&gt;&lt;/span&gt;&lt;/aside&gt;', 3);
</code></pre>

<p>If you provide an array of items and attempt to insert it into a single element, only the first item in the array will be inserted. If you instead insert the array of elements against another array of elements, the elements of the array will be inserted one each in every target element, matching each element in the array to the numerically corresponding element until there are no more elements in the array or no more elements in the target collection:</p>

<pre class="prettyprint"><code>var nodes = $('&lt;p&gt;1&lt;/p&gt;&lt;p&gt;2&lt;/p&gt;&lt;p&gt;3&lt;/p&gt;');

// Only '&lt;p&gt;1&lt;/p&gt;' will be inserted.
$('li').eq(1).insert(nodes, 2);

// Nodes will be insert in order into each list item.
// If there are four list items, each one will a p tag in
// the order they are from the array:
 $('li').insert(nodes, 2);

// Possible results from the above:
&lt;li&gt;
   &lt;h2&gt;Title 1&lt;/h2&gt;
   &lt;p&gt;1&lt;/p&gt;
   &lt;h3&gt;Subtitle 1&lt;/h3&gt;
   &lt;p&gt;Detail 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
   &lt;h2&gt;Title 2&lt;/h2&gt;
   &lt;p&gt;2&lt;/p&gt;
   &lt;h3&gt;Subtitle 2&lt;/h3&gt;
   &lt;p&gt;Detail 2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
   &lt;h2&gt;Title 3&lt;/h2&gt;
   &lt;p&gt;3&lt;/p&gt;
   &lt;h3&gt;Subtitle 3&lt;/h3&gt;
   &lt;p&gt;Detail 3&lt;/p&gt;
&lt;/li&gt;
</code></pre>

<h3>
<a name="cc-clone" class="anchor" href="#clone" aria-hidden="true"><span class="octicon octicon-link"></span></a>clone</h3>

<p>This method will create a clone of the element upon which it is executed. If a falsy value is passed as na argument, the clone will only be of the element. Otherwise the method will clone the element with its descendant nodes. Falsy values are false, undefined and null. Do not wrap them in quotes or they will be resolved to true. (Yeah, JavaScript is weird that way.) When cloning an element, any events that were directly bound to it will be not be present in the clone. This is where delegated events help.</p>

<pre class="prettyprint"><code>// Create a clone of a list item and append it to the same list:
var clonedListItem = $('#list').find('li').eq(0).clone();
$('#list').append(clonedListItem);
</code></pre>

<pre class="prettyprint"><code> // Create a shallow clone of a list item:
var shallowClone = $('li').eq(0).clone(false);
</code></pre>

<h3>
<a name="cc-wrap" class="anchor" href="#wrap" aria-hidden="true"><span class="octicon octicon-link"></span></a>wrap</h3>

<p>This method will wrap the element in the provided markup. This method expects a string of valid markup. It will cut the element from the page, wrap the provided markup around it and insert it back into its previous location.</p>

<pre class="prettyprint"><code>// Wrap a list in a div:
$('myList').wrap('&lt;div class='menu'&gt;&lt;/div&gt;');

// Wrap all list icons in an anchor button:
$('li').find('.icon').wrap('&lt;a class="button" href="javascript:void(null)"&gt;&lt;/a&gt;');
</code></pre>

<h3>
<a name="cc-unwrap" class="anchor" href="#unwrap" aria-hidden="true"><span class="octicon octicon-link"></span></a>unwrap</h3>

<p>This method removes the parent of the element. It does this be clone the element, deleting its parent and insert the cloned element in the parents position. This will therefore remove any events bound to the element being unwrapped. If you need events for it, use a delegated event.</p>

<pre class="prettyprint"><code>// Remove the parent of the list:
$('#myList').unwrap();
</code></pre>

<h3>
<a name="cc-remove" class="anchor" href="#remove" aria-hidden="true"><span class="octicon octicon-link"></span></a>remove</h3>

<p>This method will remove the element from the document. Before doing so, it will unbind any events associated with it or its descendants.</p>

<pre class="prettyprint"><code>// Remove the last list item from the list:
$('li').eq(-1).remove();
</code></pre>

<pre class="prettyprint"><code>// Remove all list items with the class 'selected':
$('li.selected').remove();;
</code></pre>

<h3>
<a name="cc-empty" class="anchor" href="#empty" aria-hidden="true"><span class="octicon octicon-link"></span></a>empty</h3>

<p>This method will empty an element, removing its child nodes.</p>

<pre class="prettyprint"><code>// Empty the last list item and append new content:
$('li').eq(-1).empty().append('&lt;h3&gt;New Stuff Here!&lt;/h3&gt;');
</code></pre>

<h3>
<a name="cc-replace" class="anchor" href="#replace" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.replace</h3>

<p>This method will replace one element with another. The first argument is the element that will be replaced, the second argument is the element to be replaced. The process of replacing will pluck the node replacing from its place in the document and inserted in the position of the node being replaced.</p>

<pre class="prettyprint"><code>var oldTag = $('#oldTag');
var newTag = $('#newTag');
$.replace(oldTag, newTag);

</code></pre>

<h2>
<a name="cc-reading-dom-properties" class="anchor" href="#reading-dom-properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reading DOM Properties</h2>

<p>ChocolateChipJS provides the following methods to get various DOM properties.</p>

<ul>
<li>$(selector).offset()</li>
<li>$(selector).width()</li>
<li>$(selector).height()</li>
<li>$(selector).text()</li>
<li>$(selector).html()</li>
<li>$(selector).attr()</li>
<li>$(selector).class()</li>
<li>$(selector).dataset()</li>
<li>$(selector).data()</li>
</ul><h3>
<a name="cc-offset" class="anchor" href="#offset" aria-hidden="true"><span class="octicon octicon-link"></span></a>offset</h3>

<p>This method will return the absolute coordinates of the first element in the collection. In other words, it returns an object with the top, left, bottom, and right of the element from the top left of the screen. For the width and height, including padding and borders, use the <code>$(selector).width()</code> and <code>$(selector).height()</code> methods described above. Since it is returning an object of values, you cannot chain other collection methods to it.</p>

<pre class="prettyprint"><code>// Returns an object with top, left, bottom and right
var offset = $('.list').offset(); 
// Get just the top:
var top = $('.list').offset().top;
</code></pre>

<h3>
<a name="cc-width" class="anchor" href="#width" aria-hidden="true"><span class="octicon octicon-link"></span></a>width</h3>

<p><code>$(selector).width()</code> is a convenience method for getting the width on an element. It will return the width as an integer without the length identifier the <code>$(selector).css('width')</code> would. This works with DOM nodes. If you need the window width, use <code>window.innerWidth</code> Trying to get the width of the window object will return 'undefined'. In the case of a collection of multiple nodes, this method returns the width of only the first element in the collection.</p>

<pre class="prettyprint"><code>// Get the width of the first list item:
var width = $('li').width();

// Try to get window width:
$(window).width() // returns undefined
// Get the window's width:
var windowWidth = window.innerWidth;
</code></pre>

<h3>
<a name="cc-height" class="anchor" href="#height" aria-hidden="true"><span class="octicon octicon-link"></span></a>height</h3>

<p><code>$(selector).height()</code> is a convenience method for getting the height on an element. It will return the height as an integer without the length identifier the <code>$(selector).css('height')</code> would. This works with DOM nodes. If you need the window height, use <code>window.innerHeight</code> Trying to get the height of the window object will return 'undefined'. In the case of a collection of multiple nodes, this method returns the height of only the first element in the collection.</p>

<pre class="prettyprint"><code>// Get the height of the first list item:
var height = $('li').height();

// Try to get window height:
$(window).height() // returns undefined
// Get the window's height:
var windowHeight = window.innerHeight;
</code></pre>

<h3>
<a name="cc-text" class="anchor" href="#text" aria-hidden="true"><span class="octicon octicon-link"></span></a>text</h3>

<p>This method allows you to set or retrieve the text of an element. To set text on an element, just provide a string to text as the argument. Be aware that this will replace everything in the element with the provided string. That means if the element has child nodes, these will be replaced as well, leaving only the string. If the method is executed without any argument, it returns the text content of the element. This includes the text of all child elements as well.</p>

<p>When executed on a collection, it will set the provided string on all elements, or return combined text of all elements.</p>

<pre class="prettyprint"><code>// Set text on the first list item:
$('li').eq(0).text('New Text Here!');

// Set text on all list items:
$('li').text('New Text');

// Get text of first list item:
var text = $('li').eq(0).text();

// Get text of all list items:
var text = $('li').text();
</code></pre>

<h3>
<a name="cc-html-3" class="anchor" href="#html-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>html</h3>

<p>This method will replace the contents of the target element(s) with the content provided. If no argument is provided, it will return all the contents of the element, including nodes. If a string is provided as an argument, that string will replace the contents of the element. If the string is markup, it will be converted to nodes before inserting. If the string is empty (''), then the contents of the element will be replaced with an empty text node.</p>

<pre class="prettyprint"><code> // Get all the items in the menu:
var contents = $('#menu').html();

// Empty the first item in the list:
$('li').eq(0).html('');

// Replace the content of all list items with text:
$('li').html('New Text Here!');

// Replace the content of all list items with new markup:
$('li').html('&lt;h2&gt;New List Title&lt;/h2&gt;');
</code></pre>

<h3>
<a name="cc-attr-2" class="anchor" href="#attr-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>attr</h3>

<p>This method gets or sets the attribute of elements. If only an attribute is provided, it will return the attribute value of the first element in the collection. If an attribute and value are provided, they will be set on all elements in the array.</p>

<pre class="prettyprint"><code>// Get the checked state of the input in the first list item.
// (true or false): 
var checked = $('li').find('input').attr('checked'); 

// Set the checked state: 
var checked = $('li').eq(0).find('input').attr('checked', 'checked');

// Set the aria role of all buttons: 
$('button').attr('role', 'button');
</code></pre>

<h3>
<a name="cc-dataset-2" class="anchor" href="#dataset-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>dataset</h3>

<p>This method is used to get or set HTML5 data attributes on elements. You provide two arguments for setting a value: the attribute name and the value for it. The attribute provided will automatically have 'data-' prepended to it, so you just provide the name for the attribute and the value it should hold. The value must be a string. You could store not string data by converting it to a string. However, ChocolateChipJS provides a more efficient way to do this using the data method, which allows you to cache data objects in relation to an element.</p>

<p>To retrieve a dataset, just provide the name of the attribute as an argument.</p>

<pre class="prettyprint"><code>// Set a data attribute.
// This will attrach the attribute like so: data-price='$2.00'.
$('li').eq(0).dataset('price', '$2.00');

// Get the data attribute:
var price = $('li').eq(0).dataset('price');

// Set the data attribute on all list items:
$('li').dataset('availability', 'in-stock');
</code></pre>

<p>When getting the data attribute on an array of elements, this method will return the value of the first element only:</p>

<pre class="prettyprint"><code>var value = $('li').dataset('availability');
// This is the same as:
var value = $('li').eq(0).dataset('availability');
</code></pre>

<h3>
<a name="cc-data-2" class="anchor" href="#data-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>data</h3>

<p>This method will get and set data in relation to an element. Unlike the HTML5 data attribue, nothing is stored on the element. Instead the data is stored in a cache and tied to the element through its id. If the element has no id at the time the data is bound, the element is given a unique id to identify it in the cache.</p>

<pre class="prettyprint"><code>$('li').on('singletap', function() { 
  // Store the list item title in the list's data cache: 
  $(this).parent().data('selectedItem', $(this).find(h3).text());
});
</code></pre>

<h2>
<a name="cc-events" class="anchor" href="#events" aria-hidden="true"><span class="octicon octicon-link"></span></a>Events</h2>

<p>ChocolateChipJS has a number of function to help you handle events efficiently.</p>

<ul>
<li>$(selector).bind()</li>
<li>$(selector).unbind()</li>
<li>$(selector).delegate()</li>
<li>$(selector).undelegate()</li>
<li>$(selector).on()</li>
<li>$(selector).off()</li>
<li>$(selector).trigger()</li>
</ul><h3>
<a name="cc-bind" class="anchor" href="#bind" aria-hidden="true"><span class="octicon octicon-link"></span></a>bind</h3>

<p>This method binds events to nodes along with a callback. A third optional argument can set for the capture phase. By default it is false, but you can pass a boolean true value to change that behavior. In most cases you want the capture phase to resolve to false.</p>

<p>ChocolateChipJS uses its caching system to keep track of which events youve bound to an element to facility unbinding them at a later time. Please see the documentation for unbind for more information.</p>

<pre class="prettyprint"><code>var doSomething = function() {
   console.log("I'm doing it now.");
};
$("#doIt").bind("click", doSomething);
// or:
$(".stop").bind("touchend", function() {
  console.log("Time to put an end to this!");
  // Delete the element
  this.remove();
});

// Bind a named callback:
var buttonInteraction = function() {
  // The keyword 'this' will be the button clicked in the callback:
  $(this).addClass('selected').css('border','solid 1px red');
};
// Bind event with buttonIneraction:
$('button').bind('singletap', buttonInteraction, false);
</code></pre>

<p>To get the event of the user interaction you can use any parameter inside the callback's parenthesis. This will give you access to the event object.</p>

<pre class="prettyprint"><code>// We're using 'event' as the parameter,
// you can use whatever you want:
$('.button').bind('singletap', function(event) {
// Log the event object:
console.dir(event);
// Get the name of the target element of the event:
console.log(event.target.nodeName);
});
</code></pre>

<p>Binding events to every element, particularly in a long list, is not very efficient. In those cases you should instead use event delegation. To see how that is implemented, look at the documentation for the "delegate" and "on" methods.</p>

<h3>
<a name="cc-unbind" class="anchor" href="#unbind" aria-hidden="true"><span class="octicon octicon-link"></span></a>unbind</h3>

<p>This method will unbind and event from an element. When events are bound, memory is taken up by that. Unbinding events that are no longer needed will free up memory. In order to unbind an event you need to have acces to the element, the function, and the capture phase used, otherwise you will not be able to unbind it. Fortunately, ChocolateChipJS uses a caching system when bind events. This keeps a log of all events attached to an element. When you execute the unbind method on an element, the method searches the cache for the element and removes all events in the cache that match the parameters provided. If you only passed no arguments, all event handlers would be removed from the element. If you passed the only an event, all events of that type would be deleted, even if there were multiple instances of the event with different callbacks. If you named the callback which the event uses, you can pass the event and the callback name to only remove that event. Similarly, you can further distinguish which event your are removing by also providing the capture phase.</p>

<pre class="prettyprint"><code>// Remove all events from the button:
$('#myButton').unbind();

// Remove all 'click' events:
$('#myButton').unbind('click');

// Remove the click event with the callback "doIt":
$('#myButton').unbind('click', 'doIt');

// Remove the click event with the callback "doIt",
// but only is the capture phase is true:
$('#myButton').unbind('click', 'doIt', 'true');
</code></pre>

<p>Deleting an element from the document without first unbinding events will lead to serious memory leaks, which can result in sluggish performance or a crash. When using ChocolateChipJS's 'remove' method, it automatically unbinds all events on an element and its descendants to prevent memory leaks.</p>

<h3>
<a name="cc-delegate" class="anchor" href="#delegate" aria-hidden="true"><span class="octicon octicon-link"></span></a>delegate</h3>

<p>This method allows you to register an event listener at a higher level to trap user interaction on descendant elements. For example, registering a even on a list to capture user interaction with the list items. This is more memory efficient that attaching an event to every list item. This also allows you to add and remove items while still maintaining interactivity with the elements.</p>

<p>A common mistake with event delegation is to register them all on the body tag. This is also not very efficient because the events have to bubble all the way to the body tag before they can be trapped. Always try to register the delegates as close to their targets as possible, this will avoid a sluggish performance of event triggering.</p>

<p>The delegate function expects the following arguments: selector, event, callback, capturePhase. Selector is the target of the event. If no capturePhase is provided it will default to 'false'.</p>

<pre class="prettyprint"><code>$('.list').delegate('li', 'singletap', function() {
  // This refers to the element receiving the single tap:
  $(this).addClass('selected');
  console.log($(this).text());
}, false);

$('.list).delegate('li', 'swiperight', function() {
  // Hide the list item if the user swipes right:
  $(this).hide('fast');
});
</code></pre>

<h3>
<a name="cc-undelegate" class="anchor" href="#undelegate" aria-hidden="true"><span class="octicon octicon-link"></span></a>undelegate</h3>

<p>Like unbind, this method will remove the designated delegated events. It expects the following parameters: selector, event, callback, capturePhase. If no capturePhase if provided, it will default to false. If no event is provided, all events on the element will be removed. If you named the callback, you can provide its name for greater specificity.</p>

<pre class="prettyprint"><code>// Add a delegate to the body tag:
var markSelect = function(item) {
  $(item).addClass('selected');
};
// $.eventEnd is alias to whatever event is supported by the device:
// mousedown, touchstart, MSPointerDown, etc.
$("body").delegate($.eventStart, markSelect);

// Remove the delegate:
$("body").undelegate($.eventStart);
</code></pre>

<h3>
<a name="cc-on" class="anchor" href="#on" aria-hidden="true"><span class="octicon octicon-link"></span></a>on</h3>

<p>This is a shortcut for both bind and delegate, as such the parameter order is different. This bind and event it is the same as for bind, but if you want to create a delegate, then you use the parameter order of the delegate event. ChocolateChipJS examines the parameters you provide to determine whether you want to bind an event or create a delegate.</p>

<pre class="prettyprint"><code>// Bind an event:
$('.button').on('singletap', function() {
  $(this).addClass('selected');
  // Output the name of the button to the #result element:
  $('#result').html($(this).text());
});
</code></pre>

<p>To create a delegate, the parameter order is slightly different from the delegate method. You put the event first, followed by the element to listen for, followed by the callback and capture phase:</p>

<pre class="prettyprint"><code>// Create a delegated event:
$('ul').on('singletap', 'li', function() {
  $(this).siblings().removeClass('selected');
  $(this).addClass('selected');
}, false);
</code></pre>

<h3>
<a name="cc-off" class="anchor" href="#off" aria-hidden="true"><span class="octicon octicon-link"></span></a>off</h3>

<p>This is a shortcut for both unbind and undelegate. Like unbind and undelegate, it removes events based on the parameters you provide.</p>

<pre class="prettyprint"><code>// Remove all events from the button:
$('#myButton').off();

// Remove all 'click' events:
$('#myButton').off('click');

// Remove the click event with the callback "doIt":
$('#myButton').off('click', 'doIt');

// Remove the click event with the callback "doIt",
// but only is the capture phase is true:
$('#myButton').off('click', 'doIt', 'true');

// Remove delegate for the callback is 'purchaseDecision':
$("body").undelegate($.eventStart, purchaseDecision);

// Remove delegate from list where the callback is 'listSelection':
$('#myList').undelegate('singletap', listSelection, false);
</code></pre>

<h3>
<a name="cc-trigger" class="anchor" href="#trigger" aria-hidden="true"><span class="octicon octicon-link"></span></a>trigger</h3>

<p>This method will trigger the provided event on its target element. If the element does not have an event of the type being sent, nothing will happen. So, if you find that triggered events are not firing on an element, check to make sure you are triggering the correct event type. ChocolateChip-UI uses many types of events for capturing user interactions, such as mouse down, touch, single tap, double tap, swipe, etc.</p>

<pre class="prettyprint"><code>// Trigger a singletap event on the back button of the current article:
$('nav.current').find('.back').trigger('singletap');
</code></pre>

<h2>
<a name="cc-ajax" class="anchor" href="#ajax" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ajax</h2>

<p>ChocolateChipJS provides a number of methods to enable various Ajax operations.</p>

<ul>
<li>$.ajax()</li>
<li>$.get()</li>
<li>$.getJSON()</li>
<li>$.post()</li>
<li>$.JSONP()</li>
<li>$.form2JSON()</li>
</ul><h3>
<a name="cc-ajax-2" class="anchor" href="#ajax-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.ajax</h3>

<p>This method allows you to execute an Ajax operation. You pass in an object literal of the properties you wish to execute. It expects at a minimal a URL to access. It has the foolowing default settings:</p>

<pre class="prettyprint"><code>var settings = {
  type: 'GET',
  beforeSend: $.noop,
  success: $.noop,
  error: $.noop,
  context: null,
  async: true,
  timeout: 0
};
</code></pre>

<p>You can use the $.ajax method to retrieve HTML fragments to insert in your document:</p>

<pre class="prettyprint"><code>$.ajax({
  url : "announcement.html",
  success : function(data) {
    // Insert the fragment into the page:
    $("#content").html(data);
  },
  error: function(data) {
    $("#content").html("&lt;h4&gt;There was an error while trying to get the file.&lt;/h4&gt;");
  }
});
</code></pre>

<p>You can also request an external JSON file for user in your app:</p>

<pre class="prettyprint"><code>$.ajax({
  url : "me.json",
  success : function(data) {
    // Before using a JSON object, you need to parse it.
    // Here we parse it and assign it to a variable:
    var me = JSON.parse(data);
    // Here we access the properties of the JSON object:
    $("#content").html(me.firstName + " " + me.lastName);
  },
  error: function(data) {
    content.html("&lt;h4&gt;There was an error while trying to get the file.&lt;/h4&gt;");
  }
});
</code></pre>

<p>We can also do a post to a remote server:</p>

<pre class="prettyprint"><code>$.ajax({
  url : "/path/to/controller",
  method: 'POST',
  headers: {
    "Content-Type" : "application/x-www-form-urlencoded",
    "async" : true,
    "Access-Control-Allow-Origin" : "*",
    "Accept" : "text/plain"
  },
  data: myData,
  success : mySuccessCallback,
  error: myErrorCallback
});
</code></pre>









<h2>
<a name="cc-animation" class="anchor" href="#ecmascript_promises" aria-hidden="true"><span class="octicon octicon-link"></span></a>ECMAScript Promises</h2>

<p>As of 3.8.6, the default build of ChocolateChipJS supports ECMAScript 6 promises. This includes all of its Ajax methods as well. ChocolateChipJS provides a polyfill for older browsers that do not have support for ECMAScript 6 promises, so you can use them in your code immediately.</p>

<p>ECMAScript 6 Promises provide the following interface:</p>

<ol>
  <li>Promise</li>
  <li>Promise.then()</li>
  <li>Promise.resolve()</li>
  <li>Promise.reject()</li>
  <li>Promise.catch()</li>
  <li>Promise.race()</li>
  <li>Promise.all()</li>
</ol>

<p>If you are familiar and have been using jQuery or ChocolateChipJS's Deferred object, this will not look too foreign. Except for the last two: race and all. These have no equivalent with typical deferreds. They are features specific to ECMAScript promises.</p>

<h3>The Promise Interface</h3>

<p>An ECMAScript 6 promise is created with the "new" keyword. This returns an instance of the Promise object.</p>

<pre class="prettyprint"><code>var myPromise = new Promise();
</code></pre>

<p>When you create a promise, you can also provide a callback. This will be able to handle two arguments: resolve and reject:</p>

<pre class="prettyprint"><code>var myPromise = new Promise(function(resolve, reject) {
  var value;
  // Do something to get value;
  // ...
  // Then test value to determine how to handle the promise:
  if (value === 'good') {
    resolve(value);
  } else {
    // When you reject the promise,
    // you also get the reason it failed,
    // which you can choose to output if you want:
    reject(reason);
  }
});
</code></pre>

<h4>Then</h4>
<p>Proimses provide several methods allowing us to do useful things. The way you'll most like use promises is with the <code>then</code> method. This method can take up two two callbacksone for success and one for failure.</p>


<pre class="prettyprint"><code>// Create an instance of a promise:
var myPromise = new Promise(function(resolve, reject) {
  // Resolve the promise:
  resolve('Success!');
  // or reject it:
  // reject('Lost in Space!');
});
myPromise.then(function(value) {
  // Success:
  console.log(value);
},
// Opps! There was a problem:
function(reason) {
  console.log(reason);
});
</code></pre>

<p>As you can see in the above code, <code>then</code> can handle two callbacks, one for success and another optional one for failure. You can just provide a single callback to handle the success. That's up to you. If you want, you could return whatever value you get in your success callback, which allows you to chain a second fuction. Read the next part on Multiple Thens for more information.</p>

<h4>Multiple Thens</h4>
<p>The <code>then</code> method always returns a promsie. This means that you can chain mutliple thens together. This allows you to break your code up into more logical blocks. This also helps you to avoid one of JavaScript development's worse patternsthe pyramid of doomdeeply nest series of callbacks.</p>

<pre class="prettyprint"><code>var myPromise = new Promise(function(resolve, reject) {
  resolve(1);
});
myPromise.then(function(value) {
  console.log(value); // 1
  // Return the value:
  return value + 1;
})
.then(fuction(value) {
  console.log(value) // 2
})
</code></pre>


<h4>Resolve</h4>

<p>We can resolve a promise at any time using the <code>resolve</code> method on the static Promise object. Once we execute the resolve method, the promise is disposed of. </p>

<pre class="prettyprint"><code>// Define an alias for the resolve callback:
var fulfill;
new Promise(function (resolve, reject) {
  fulfill = resolve;
}).then(function(value) {
  equal(value, 5, 'Promise fulfilled with Promise should resolve to actual value');
  start();
});
fulfill(Promise.resolve(5));
</code></pre>

<h4>Reject</h4>

<p>Like the resolve example above, we can similarly reject a promise using its method on the static Promise object. In this example we pass a value that gets returned with the rejection:</p>

<pre class="prettyprint"><code>var fulfill;
new Promise(function (resolve, reject) {
  fulfill = resolve;
})['catch'](function(value) {
  console.log(value);
});
fulfill(Promise.reject(5));
</code></pre>

<h4>Catch</h4>

<p>We can handle errors and exceptions using the <code>catch</code> method. This enables us to have a series of thens that only handle success situations. ECMAScript promise pass any exception along until their is some callback to handle it.</p>

<pre class="prettyprint"><code>var myPromise = new Promise(function(resolve, reject) {
  resolve("Success!");
});
myPromise.then(function(value) {
  console.log(value); // Success!
  throw "Oops! Something went wrong.";
})
.catch(function(error) {
  console.log(error); // Oops! Something went wrong.
})
</code></pre>

<h4>Race</h4>

<p>Sometimes you may need to execute several operations and any one of them could finish first. You want to take the result of the first to finishing, ignoring the others. ECMAScript promises enable this with the <code>race</code> method. This expects an array of promises as its argument.</p>

<pre class="prettyprint"><code>var f1, f2, f3;
var p1 = new Promise(function(f, r) { f1 = f; });
var p2 = new Promise(function(f, r) { f2 = f; });
var p3 = new Promise(function(f, r) { f3 = f; });
Promise.race([p1, p2, p3]).then(function(value) {
  console.log('Promise.race() should resolve to: ' + value);
});
// Execute the second:
f2(2);
</code></pre>

<h4>All</h4>
<p>Unlike with race conditions, sometimes you want to execute a number of things and wait until they are all done before doing anything. In those cases you can use the <code>all</code> method. This expects an array of promises as its argument.</p>

<pre class="prettyprint"><code>var f1, f2, f3;
var p1 = new Promise(function(f, r) { f1 = f; });
var p2 = new Promise(function(f, r) { f2 = f; });
var p3 = new Promise(function(f, r) { f3 = f; });
Promise.all([p1, p2, p3])
.then(function(value) {
  console.log(value);
});
// Execute theme in opposite order:
f3(3);
f2(2);
f1(1);
</code></pre>


<a name="cc-animation" class="anchor" href="#ajax_promises" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ajax with ECMAScript Promises</h2>

<p>You can use ECMAScript 6 promises with ChocolateChipJS's Ajax functions as well. These functions have been rewritten to always return promises. Below is a conceptual example showing the handling of a success and error in a GET request:</p>

<pre class="prettyprint"><code>$.get('http://my.com/data/stuff.html')
.then(function(response) {
  console.log("Success!", response);
}, function(error) {
  console.error("Failed!", error);
});
</code></pre>

<p>We could also further separate our error handling in a catch statement:</p>

<pre class="prettyprint"><code>$.get('http://my.com/data/stuff.html')
.then(function(response) {
  console.log("Success!", response);
})
.then(function(data) {
  $('#content').append(data);
})
.catch(function(error) {
  console.error("Failed!", error);
});
</code></pre>

<p>Here's an example of parsing the JSON text from a request:</p>

<pre class="prettyprint"><code>$.get('story.json')
.then(JSON.parse)
.then(function(response) {
  console.log("Yey JSON!", response);
});
</code></pre>

<p>And here's an example of doing multiple Ajax requests but only output the first to come back:</p>

<pre class="prettyprint"><code>var getStuff1 = $.get('data-1.json');
var getStuff2 = $.get('data-1.json');
var getStuff3 = $.get('data-1.json');
Promise.race([getStuff1, getStuff2, getStuff3)])
.then(function(response) {
  $('#result').append(response);
})
.catch(function(error) {
  console.log('There was a problem: ', error);
})
</code></pre>

<p>Or we might want to wait for all of them to come back before outputting the results:</p>

<pre class="prettyprint"><code>var getStuff1 = $.get('data-1.json');
var getStuff2 = $.get('data-1.json');
var getStuff3 = $.get('data-1.json');
Promise.all([getStuff1, getStuff2, getStuff3)])
.then(function(response) {
  $('#result').append(response);
})
.catch(function(error) {
  console.log('There was a problem: ', error);
})
</code></pre>




















<h2>
<a name="cc-deferred-object" class="anchor" href="#deferred-object" aria-hidden="true"><span class="octicon octicon-link"></span></a>Deferred Object</h2>

<p><strong>Note:</strong> As of version 3.8.6, ChocolateChipJS uses ECMAScript 6 promises. Previously it used a deferred object compatible with the jQuery implementation. If you prefer that, you can still build ChocolateChipJS with suppor for it using the flag <code>--deferredSupport</code>:</p>
<pre class="prettyprint"><code>gulp --deferredSupport</code></pre>

<p>The Deferred object can register multiple callbacks into callback queues, invoke callback queues, and relay the success or failure state of any synchronous or asynchronous function. This implementation is based on the version in jQuery 1.7. Please examine the unit tests to see how to use it.</p>

<p>The Deferred object is chainable, similar to the way ChocolateChip methods are chainable, but it has its own methods. After creating a Deferred object, you can use any of the methods below by either chaining directly from the object created, or saving the object in a variable and invoking one or more methods on that variable.</p>

<ul>
<li>$.Deferred</li>
<li>done</li>
<li>fail</li>
<li>always</li>
<li>pipe</li>
<li>progress</li>
<li>notify</li>
<li>notifyWith</li>
<li>state</li>
<li>isResolved</li>
<li>isRejected</li>
<li>resolve</li>
<li>resolveWith</li>
<li>reject</li>
<li>rejectWith</li>
<li>then</li>
<li>when</li>
</ul><h3>
<a name="cc-deferred" class="anchor" href="#deferred" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.Deferred</h3>

<p>A constructor function that returns a chainable utility object with methods to register multiple callbacks into callback queues, invoke callback queues, and relay the success or failure state of any synchronous or asynchronous function.</p>

<p>The $.Deferred method can be passed an optional function, which is called just before the constructor returns and is passed the constructed deferred object as both the this object and as the first argument to the function. The called function can attach callbacks using <code>deferred.then()</code>, for example.</p>

<p>A Deferred object starts in the pending state. Any callbacks added to the object with <code>deferred.then()</code>, <code>deferred.always()</code>, <code>deferred.done()</code>, or <code>deferred.fail()</code> are queued to be executed later. Calling <code>deferred.resolve()</code> or <code>deferred.resolveWith()</code> transitions the Deferred into the resolved state and immediately executes any doneCallbacks that are set. Calling <code>deferred.reject()</code> or <code>deferred.rejectWith()</code> transitions the Deferred into the rejected state and immediately executes any failCallbacks that are set. Once the object has entered the resolved or rejected state, it stays in that state. Callbacks can still be added to the resolved or rejected Deferred  they will execute immediately.</p>

<p>Enhanced Callbacks with $.Deferred</p>

<p>In JavaScript it is common to invoke functions that optionally accept callbacks that are called within that function.</p>

<p>$.Deferred() introduces several enhancements to the way callbacks are managed and invoked. In particular, $.Deferred() provides flexible ways to provide multiple callbacks, and these callbacks can be invoked regardless of whether the original callback dispatch has already occurred.</p>

<p>One model for understanding Deferred is to think of it as a chain-aware function wrapper. The <code>deferred.then()</code>, <code>deferred.always()</code>, <code>deferred.done()</code>, and <code>deferred.fail()</code> methods specify the functions to be called and the deferred.resolve(args) or deferred.reject(args) methods "call" the functions with the arguments you supply. Once the Deferred has been resolved or rejected it stays in that state; a second call to <code>deferred.resolve()</code>, for example, is ignored. If more functions are added by <code>deferred.then()</code>, for example, after the Deferred is resolved, they are called immediately with the arguments previously provided.</p>

<pre class="prettyprint"><code>var deferred = new $.Deferred();

// or without the new keyword:

var deferred = $.Deferred();
</code></pre>

<h3>
<a name="cc-done" class="anchor" href="#done" aria-hidden="true"><span class="octicon octicon-link"></span></a>done</h3>

<p>Add handlers to be called when the Deferred object is resolved. The argument can be a function, or array of functions, that is called when the Deferred is resolved or rejected.</p>

<p>The <code>deferred.done()</code> method accepts one or more arguments, all of which can be either a single function or an array of functions. When the Deferred is resolved, the doneCallbacks are called. Callbacks are executed in the order they were added. Since <code>deferred.done()</code> returns the deferred object, other methods of the deferred object can be chained to this one, including additional <code>.done()</code> methods. When the Deferred is resolved, doneCallbacks are executed using the arguments provided to the resolve or resolveWith method call in the order they were added.</p>

<pre class="prettyprint"><code>&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;deferred.done demo&lt;/title&gt;
  &lt;script src="chui/chocolatechip.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;button&gt;Go&lt;/button&gt;
&lt;p&gt;Ready...&lt;/p&gt;

&lt;script&gt;
// 3 functions to call when the Deferred object is resolved
function fn1() {
  $( "p" ).append( " 1 " );
}
function fn2() {
  $( "p" ).append( " 2 " );
}
function fn3( n ) {
  $( "p" ).append( n + " 3 " + n );
}

// Create a deferred object
var dfd = $.Deferred();

// Add handlers to be called when dfd is resolved
dfd
// .done() can take any number of functions or arrays of functions
  .done( [ fn1, fn2 ], fn3, [ fn2, fn1 ] )
// We can chain done methods, too
  .done(function( n ) {
    $( "p" ).append( n + " we're done." );
  });

// Resolve the Deferred object when the button is clicked
$( "button" ).on( "click", function() {
  dfd.resolve( "and" );
});
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3>
<a name="cc-fail" class="anchor" href="#fail" aria-hidden="true"><span class="octicon octicon-link"></span></a>fail</h3>

<p>Add handlers to be called when the Deferred object is rejected. The argument can be a function, or array of functions, that is called when the Deferred is resolved or rejected.</p>

<p>The <code>deferred.fail()</code> method accepts one or more arguments, all of which can be either a single function or an array of functions. When the Deferred is rejected, the failCallbacks are called. Callbacks are executed in the order they were added. Since <code>deferred.fail()</code> returns the deferred object, other methods of the deferred object can be chained to this one, including additional <code>deferred.fail()</code> methods. The failCallbacks are executed using the arguments provided to the <code>deferred.reject()</code> or <code>deferred.rejectWith()</code> method call in the order they were added.</p>

<pre class="prettyprint"><code>// Create a deferred object
var dfd = $.Deferred();

dfd.done(/* Do stuff when done */).fail(/* Do stuff when fail */);
</code></pre>

<h3>
<a name="cc-always" class="anchor" href="#always" aria-hidden="true"><span class="octicon octicon-link"></span></a>always</h3>

<p>Add handlers to be called when the Deferred object is either resolved or rejected. The argument can be a function, or array of functions, that is called when the Deferred is resolved or rejected.</p>

<p>The argument can be either a single function or an array of functions. When the Deferred is resolved or rejected, the callbacks are called. Since <code>deferred.always()</code> returns the Deferred object, other methods of the Deferred object can be chained to this one, including additional <code>.always()</code> methods. When the Deferred is resolved or rejected, callbacks are executed in the order they were added, using the arguments provided to the resolve, reject, resolveWith or rejectWith </p>

<pre class="prettyprint"><code>// Create a deferred object
var dfd = $.Deferred();
dfd
  .done(/* Do stuff when done */)
  .fail(/* Do stuff when fail */)
  .always(/* This will always execute for done and fail */);
</code></pre>

<h3>
<a name="cc-pipe" class="anchor" href="#pipe" aria-hidden="true"><span class="octicon octicon-link"></span></a>pipe</h3>

<p>Utility method to filter and/or chain Deferreds. It accepts two arguments. The first is <code>doneFilter</code> that is called when the Deferred is resolved. The second is <code>failFilter</code> that is called when the Deferred is rejected.</p>

<p>The <code>deferred.pipe()</code> method returns a new promise that filters the status and values of a deferred through a function. The <code>doneFilter</code> and <code>failFilter</code> functions filter the original Deferred's resolved / rejected status and values. If the filter function used is null, or not specified, the piped promise will be resolved or rejected with the same values as the original.</p>

<h4>
<a name="cc-filter-resolve-example" class="anchor" href="#filter-resolve-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Filter resolve example:</h4>

<pre class="prettyprint"><code>var defer = $.Deferred();
var filtered = defer.pipe(function( value ) {
  return value * 2;
});

defer.resolve( 5 );
filtered.done(function( value ) {
  alert( "Value is ( 2*5 = ) 10: " + value );
});  
</code></pre>

<h4>
<a name="cc-filter-reject-example" class="anchor" href="#filter-reject-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Filter reject example:</h4>

<pre class="prettyprint"><code>var defer = $.Deferred(),
filtered = defer.pipe( null, function( value ) {
  return value * 3;
});

defer.reject( 6 );
filtered.fail(function( value ) {
  alert( "Value is ( 3*6 = ) 18: " + value );
});
</code></pre>

<h3>
<a name="cc-progress" class="anchor" href="#progress" aria-hidden="true"><span class="octicon octicon-link"></span></a>progress</h3>

<p>Add handlers to be called when the Deferred object generates progress notifications. It is executed from the object onto which the promise methods have to be attached.</p>

<p>The <code>deferred.promise()</code> method allows an asynchronous function to prevent other code from interfering with the progress or status of its internal request. The Promise exposes only the Deferred methods needed to attach additional handlers or determine the state (then, done, fail, always, pipe, progress, and state), but not ones that change the state (resolve, reject, notify, resolveWith, rejectWith, and notifyWith).</p>

<p>If target is provided, <code>deferred.promise()</code> will attach the methods onto it and then return this object rather than create a new one. This can be useful to attach the Promise behavior to an object that already exists.</p>

<p>If you are creating a Deferred, keep a reference to the Deferred so that it can be resolved or rejected at some point. Return only the Promise object via <code>deferred.promise()</code> so other code can register callbacks or inspect the current state.</p>

<pre class="prettyprint"><code>var dfd = $.Deferred();
// Do some stuff with dfd, 
// then do something as it progresses:
dfd.progress(function(value1, value2) {
  equal(value1, param1, 'Should equal param1.');
  equal(value2, param2, 'Should equal param2.');
  return equal(this, context, 'Should be the context.');
});
</code></pre>

<h3>
<a name="cc-notify" class="anchor" href="#notify" aria-hidden="true"><span class="octicon octicon-link"></span></a>notify</h3>

<p>Call the <code>progressCallbacks</code> on a Deferred object with the given args. Optional arguments are an object that is passed to the <code>progressCallbacks</code>.</p>

<p>Normally, only the creator of a Deferred should call this method; you can prevent other code from changing the Deferred's state or reporting status by returning a restricted Promise object through <code>deferred.promise()</code>.</p>

<p>When <code>deferred.notify</code> is called, any <code>progressCallbacks</code> added by <code>deferred.then</code> or <code>deferred.progress</code> are called. Callbacks are executed in the order they were added. Each callback is passed the args from the <code>deferred.notify()</code>. Any calls to <code>deferred.notify()</code> after a Deferred is resolved or rejected (or any <code>progressCallbacks</code> added after that) are ignored. For more information, see the documentation for Deferred object.</p>

<pre class="prettyprint"><code>var context, def, param1, param2, progressCalled;
def = new $.Deferred();
context = new Array();
param1 = 'foo';
param2 = 'bar';
progressCalled = 0; 
def.progress(function(value1, value2) {
  progressCalled += 1;
  equal(value1, param1, 'Should equal param1.');
  equal(value2, param2, 'Should equal param2.');
  return equal(this, context, 'Should be the context.');
});
def.notifyWith(context, param1, param2);
equal(progressCalled, 2, 'Should equal 2.');
def.resolve();
def.notify();
</code></pre>

<h3>
<a name="cc-notifywith" class="anchor" href="#notifywith" aria-hidden="true"><span class="octicon octicon-link"></span></a>notifyWith</h3>

<p>Call the <code>progressCallbacks</code> on a Deferred object with the given context and args.</p>

<p>Normally, only the creator of a Deferred should call this method; you can prevent other code from changing the Deferred's state or reporting status by returning a restricted Promise object through <code>deferred.promise()</code>.</p>

<p>When <code>deferred.notifyWith</code> is called, any <code>progressCallbacks</code> added by <code>deferred.then</code>or <code>deferred.progress</code> are called. Callbacks are executed in the order they were added. Each callback is passed the args from the <code>deferred.notifyWith()</code>. Any calls to <code>deferred.notifyWith()</code> after a Deferred is resolved or rejected (or any <code>progressCallbacks</code> added after that) are ignored. For more information, see the documentation for Deferred object.</p>

<p>See example for <code>notify</code> above.</p>

<h3>
<a name="cc-state" class="anchor" href="#state" aria-hidden="true"><span class="octicon octicon-link"></span></a>state</h3>

<p>Determine the current state of a Deferred object.</p>

<p>"pending": The Deferred object is not yet in a completed state (neither "rejected" nor "resolved").
"resolved": The Deferred object is in the resolved state, meaning that either <code>deferred.resolve()</code> or <code>deferred.resolveWith()</code> has been called for the object and the doneCallbacks have been called (or are in the process of being called).
"rejected": The Deferred object is in the rejected state, meaning that either <code>deferred.reject()</code> or <code>deferred.rejectWith()</code> has been called for the object and the failCallbacks have been called (or are in the process of being called).
This method is primarily useful for debugging to determine, for example, whether a Deferred has already been resolved even though you are inside code that intended to reject it.</p>

<p>You can use this to check the state of the deferred object and take some action based on it. You might use a switch state to test for the states you are interested in.</p>

<pre class="prettyprint"><code>var dfd = $.Deferred();

// Do some stuff with dfd.
// Log its state:
console.log(dfd.state());
</code></pre>

<h3>
<a name="cc-isresolved" class="anchor" href="#isresolved" aria-hidden="true"><span class="octicon octicon-link"></span></a>isResolved</h3>

<p><code>deferred.isResolved()</code> is used to determine whether a Deferred object has been resolved. This method does not accept any arguments. This is a convenience method for getting this value from the <code>state</code> method described above. </p>

<p>Returns true if the Deferred object is in the resolved state, meaning that either <code>deferred.resolve()</code> or <code>deferred.resolveWith()</code> has been called for the object and the <code>doneCallbacks</code> have been called (or are in the process of being called).</p>

<p>Note that a Deferred object can be in one of three states: pending, resolved, or rejected; use <code>deferred.isRejected()</code> to determine whether the Deferred object is in the rejected state. These methods are primarily useful for debugging, for example to determine whether a Deferred has already been resolved even though you are inside code that intended to reject it.</p>

<h3>
<a name="cc-isrejected" class="anchor" href="#isrejected" aria-hidden="true"><span class="octicon octicon-link"></span></a>isRejected</h3>

<p><code>deferred.isRejected()</code> is used to determine whether a Deferred object has been rejected. This method does not accept any arguments. This is a convenience method for getting this value from the <code>state</code> method described above. </p>

<p>Returns true if the Deferred object is in the rejected state, meaning that either <code>deferred.reject()</code> or <code>deferred.rejectWith()</code> has been called for the object and the failCallbacks have been called (or are in the process of being called).</p>

<p>Note that a Deferred object can be in one of three states: pending, resolved, or rejected; use <code>deferred.isResolved()</code> to determine whether the Deferred object is in the resolved state. These methods are primarily useful for debugging, for example to determine whether a Deferred has already been resolved even though you are inside code that intended to reject it.</p>

<h3>
<a name="cc-resolve" class="anchor" href="#resolve" aria-hidden="true"><span class="octicon octicon-link"></span></a>resolve</h3>

<p>Resolve a Deferred object and call any <code>doneCallbacks</code> with the given args.</p>

<pre class="prettyprint"><code>var dfd = $.Deferred();
// Do stuff with the deferred.
dfd.done(function() {/* Do stuff here */});
// Resolve the deferred, which will 
// cause dfd.done to execute:
dfd.resolve();
</code></pre>

<h3>
<a name="cc-resolvewith" class="anchor" href="#resolvewith" aria-hidden="true"><span class="octicon octicon-link"></span></a>resolveWith</h3>

<p>Resolve a Deferred object and call any <code>doneCallbacks</code> with the given context and args. It accepts an optional array of arguments that are passed to the <code>doneCallbacks</code>.</p>

<p>Normally, only the creator of a Deferred should call this method; you can prevent other code from changing the Deferred's state by returning a restricted Promise object through <code>deferred.promise()</code>.</p>

<p>When the Deferred is rejected, any <code>doneCallbacks</code> added by <code>deferred.then</code> or <code>deferred.fail</code> are called. Callbacks are executed in the order they were added. Each callback is passed the args from the <code>deferred.reject()</code> call. Any <code>doneCallbacks</code> added after the Deferred enters the rejected state are executed immediately when they are added, using the arguments that were passed to the <code>deferred.reject()</code> call.</p>

<pre class="prettyprint"><code>var context = ["one","two","three"];
var defer = new $.Deferred(); 
defer
  .done(function() {
    console.log('This has been resolved!');
    context.forEach(function(ctx) {
      console.log(ctx);
    });
  });
  .fail(function() {
    console.log('This has failed!');
  });

// Resolve the deferred and pass
// the array as the context:
defer.resolveWith(context);

// outputs:
// "This has been resolved!"
// "one"
// "two"
// "three"

</code></pre>

<h3>
<a name="cc-reject" class="anchor" href="#reject" aria-hidden="true"><span class="octicon octicon-link"></span></a>reject</h3>

<p>Reject a Deferred object and call any <code>failCallbacks</code> with the given args. It accpets optional arguments that are passed to the <code>failCallbacks</code>.</p>

<p>Normally, only the creator of a Deferred should call this method; you can prevent other code from changing the Deferred's state by returning a restricted Promise object through <code>deferred.promise()</code>.</p>

<p>When the Deferred is rejected, any <code>failCallbacks</code> added by <code>deferred.then()</code> or <code>deferred.fail()</code> are called. Callbacks are executed in the order they were added. Each callback is passed the args from the <code>deferred.reject()</code> call. Any <code>failCallbacks</code> added after the Deferred enters the rejected state are executed immediately when they are added, using the arguments that were passed to the <code>deferred.reject()</code> call.</p>

<pre class="prettyprint"><code>var context = ["one","two","three"];
var defer = new $.Deferred(); 
defer
  .done(function() {
    console.log('This has been resolved!');
  });
  .fail(function() {
    console.log('This was rejected!')
  });

// Reject the deferred:
defer.reject();

// outputs:
// "This was rejected!"

</code></pre>

<h3>
<a name="cc-rejectwith" class="anchor" href="#rejectwith" aria-hidden="true"><span class="octicon octicon-link"></span></a>rejectWith</h3>

<p>Reject a Deferred object and call any <code>failCallbacks with</code> the given context and args. This works just like <code>deferred.resolveWith</code>, except that <code>failCallbacks</code> are executed instead of <code>doneCallbacks</code>.</p>

<pre class="prettyprint"><code>var context = ["one","two","three"];
var defer = new $.Deferred(); 
defer
  .done(function() {
    console.log('This has been resolved!');
    context.forEach(function(ctx) {
      console.log(ctx);
    });
  });
  .fail(function() {
    console.log('This was rejected!');
    console.log('The array has ' + context.length + ' items.')
  });

// Resolve the deferred and pass
// the array as the context:
defer.rejectWith(context);

// outputs:
// "This was rejected"
// "The array has 3 items."
</code></pre>

<h3>
<a name="cc-then" class="anchor" href="#then" aria-hidden="true"><span class="octicon octicon-link"></span></a>then</h3>

<p>Add handlers to be called when the Deferred object is resolved, rejected, or still in progress. It accepts the following arguments in order:</p>

<ul>
<li>doneCallbacks: A function, or array of functions, called when the Deferred is resolved.</li>
<li>failCallbacks: A function, or array of functions, called when the Deferred is rejected.</li>
<li>progressCallbacks: A function, or array of functions, called when the Deferred notifies progress.</li>
</ul><p>Callbacks are executed in the order they were added. Since deferred.then returns a Promise, other methods of the Promise object can be chained to this one, including additional <code>deferred.then()</code> methods.</p>

<pre class="prettyprint"><code>&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;deferred.then demo&lt;/title&gt;
  &lt;script src="chui/chocolatechip.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;button&gt;Filter Resolve&lt;/button&gt;
&lt;p&gt;&lt;/p&gt;

&lt;script&gt;
var filterResolve = function() {
  var defer = $.Deferred(),
    filtered = defer.then(function( value ) {
      return value * 2;
    });

  defer.resolve( 5 );
  filtered.done(function( value ) {
    $( "p" ).html( "Value is ( 2*5 = ) 10: " + value );
  });
};

$( "button" ).on( "click", filterResolve );
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3>
<a name="cc-when" class="anchor" href="#when" aria-hidden="true"><span class="octicon octicon-link"></span></a>when</h3>

<p>Provides a way to execute callback functions based on one or more objects, usually Deferred objects that represent asynchronous events. It accepsts one or more Deferred objects, or plain JavaScript objects.</p>

<p>If a single Deferred is passed to <code>$.when</code>, its Promise object (a subset of the Deferred methods) is returned by the method. Additional methods of the Promise object can be called to attach callbacks, such as <code>deferred.then</code>. When the Deferred is resolved or rejected, usually by the code that created the Deferred originally, the appropriate callbacks will be called.</p>

<p>If a single argument is passed to <code>$.when</code> and it is not a Deferred or a Promise, it will be treated as a resolved Deferred and any <code>doneCallbacks</code> attached will be executed immediately. The <code>doneCallbacks</code> are passed the original argument. In this case any <code>failCallbacks</code> you might set are never called since the Deferred is never rejected. For example:</p>

<pre class="prettyprint"><code>$.when( { testing: 123 } ).done(function( x ) {
   alert( x.testing ); // Alerts "123"
});
</code></pre>

<p>In the case where multiple Deferred objects are passed to $.when, the method returns the Promise from a new "master" Deferred object that tracks the aggregate state of all the Deferreds it has been passed. The method will resolve its master Deferred as soon as all the Deferreds resolve, or reject the master Deferred as soon as one of the Deferreds is rejected. If the master Deferred is resolved, it is passed the resolved values of all the Deferreds that were passed to $.when.</p>

<p>In the multiple Deferreds case where one of the Deferreds is rejected, $.when immediately fires the <code>failCallbacks</code> for its master Deferred. Note that some of the Deferreds may still be unresolved at that point.</p>

<pre class="prettyprint"><code>$.when(asyncEvent()).then(
  function(status){
    alert(status + ' Things are going well.');
    document.getElementById('foo').style.backgroundColor = 'green';
  },
  function(status){
    alert(status + ' You fail this time.');
    document.getElementById('foo').style.backgroundColor = 'red';
  }
);

// another example
function showDiv(){
  var dfd = $.Deferred();
  dfd.done(function(){
    document.getElementById('foo').style.display = 'block';
  });
  setTimeout(function() { dfd2.resolve() }, 2000);
  return dfd2.promise();
}
showDiv();
</code></pre>








<h4>
  <a name="cc-deferred-ajax" class="anchor" href="#deferred-ajax" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ajax with Deferred Objects</h4>

<p>When doing Ajax requests with support for the deferred object, f the Ajax request was for JSON or was a GET request, the first argument exposed to the successful deferred is the XHR.responseText. Otherwise it is the XHR.status, which lets you know whether the POST, PUT or DELETE was successful or not.</p>

<pre class="prettyprint"><code>$.ajax({ url : "/data/me.json"})
  .done(function(me) {
    $("#content").html(me.firstName + " " + me.lastName);
  })
  .fail(function(status) {
    content.html("&lt;h4&gt;There was an error while trying to get the file:" + status + "&lt;/h4&gt;");
  })
  // This executes whether a success or failure:
  .always(function() {
    console.log('An Ajax request was made to update the page.')
  })
});
</code></pre>

<h3>
<a name="cc-get" class="anchor" href="#get" aria-hidden="true"><span class="octicon octicon-link"></span></a>get</h3>

<p>This is a short cut for doing a get request. It can handle the following parameters: url, data, success, dataType. At very least you can pass it the url and a function to execute on success.</p>

<pre class="prettyprint"><code>// Get an html fragment and insert it in the document:
$.get('/data/suits.html', function(data) {
  $('#products').html(data);
});
</code></pre>

<p>Because $.get is just and alias for $.ajax, it returns a deferred object. This means you can use deferred methods with it:</p>

<pre class="prettyprint"><code>// Get an html fragment and insert it in the document:
$.get('/data/suits.html')
.done(function(data) {
  $('#products').html(data);
})
.fail(function(status) {
  $('#errorMessage').text('There was and error: ' + status)
});
</code></pre>

<h3>
<a name="cc-getjson" class="anchor" href="#getjson" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.getJSON</h3>

<p>This is a shortcut for getting a JSON object from a server. It expects three parameters: url, data, and success. If no data is provided, it will execute with just the url and success callback.</p>

<pre class="prettyprint"><code>$.getJSON('/data/deserts.json', function(deserts) {
  deserts.forEach(desert) {
    $('#deserts').append('&lt;li&gt;' + desert.name + '&lt;/li&gt;');
  });
});
</code></pre>

<p>Like the $.ajax method, this also returns a deferred object:</p>

<pre class="prettyprint"><code>$.getJSON('/data/deserts.json')
.done(function(deserts) {
  deserts.forEach(desert) {
    $('#deserts').append('&lt;li&gt;' + desert.name + '&lt;/li&gt;');
  });
})
.fail(function() {
  alert('There was a problem getting the JSON!');
});
</code></pre>

<h3>
<a name="cc-post" class="anchor" href="#post" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.post</h3>

<p>This method is a shortcut for doing a post. It expects these parameters: url, data, success, dataType.</p>

<pre class="prettyprint"><code>$.post("updateUser.php", 
  { "name": "Joe", "time": "10PM" }, 
  function() {
    console.log('The POST was successful.')
  },
  "json"
);
</code></pre>

<p>Or, with a deferred object:</p>

<pre class="prettyprint"><code>$.post("updateUser.php", 
{ 
  "name": "Joe", 
  "time": "10PM" 
})
.done(function() {
  function() {
    console.log('The POST was successful.')
  }  
})
.fail(function() {
  console.log('There was a problem posting.')
});
</code></pre>

<h3>
<a name="cc-jsonp" class="anchor" href="#jsonp" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.JSONP</h3>

<p>This method allows you to perform requests from remote sites that support JSONP. It does this by sending a callback along with the request, hence the name JSON with Padding. It expects two arguments: a url and a callback to execute once the data has returned. Normally, the url should end with the phrase: &amp;callback=?. However, there are some services out there that expect a slightly different ending. Please check the documentation for any API before trying to implement a JSONP request.</p>

<p>Because the data lives on a remote server, you'll need to read the documentation for the service to understand its format so that you can output it to your app.</p>

<p>$.JSONP has the following default settings, which you can override:</p>

<pre class="prettyprint"><code>var settings = {
  url : null,
  callback: $.noop,
  callbackType : 'callback=?',
  timeout: null
};
</code></pre>

<p>Be aware that you have no control over when the remote server will respod to your JSONP request. It could take some time. If you would prefer to have more control over what happens, you can provide a timeout value great than 0. If the remote server has not responded by the time the timeout finishes, the request will be canceled.</p>

<p>Like normal Ajax requests, $.JSONP also returns a deferred object. This allows you to use the usal deferred method chaining with your JSONP request. When the deferred object is resolved, it returns the following values in order: data (the data retrieved, 'resolved' (a string), settings (the settings object used to initialize the request). When the deferred object is rejected, it returns the following values: 'timedout' (a string), settings (the settings object used to initialize the request).</p>

<pre class="prettyprint"><code>$.JSONP({
  url: 'https://api.github.com/users/yui?callback=?', 
  callback: function(lib) {
    $('.list').append('&lt;li&gt;&lt;h3&gt;The name of the library&lt;/h3&gt;&lt;h4&gt;' + lib.data.name + '&lt;/h4&gt;&lt;/li&gt;');
  }
});

$.JSONP({
  url: 'http://www.geonames.org/postalCodeLookupJSON?postalcode=94102&amp;country=US&amp;callback=?', 
  callback: function(data){
    $('.list').append('&lt;li&gt;&lt;h3&gt;My Location&lt;/h3&gt;&lt;h4&gt;' + data.postalcodes[0].adminName2 + ', ' + data.postalcodes[0].adminName1 + '&lt;/h4&gt;&lt;/li&gt;');
  }
});
</code></pre>

<p>With timeout:</p>

<pre class="prettyprint"><code>$.JSONP({
  url: 'http://www.geonames.org/postalCodeLookupJSON?postalcode=94102&amp;country=US&amp;callback=?', 
  callback: function(data){
    $('.list').append('&lt;li&gt;&lt;h3&gt;My Location&lt;/h3&gt;&lt;h4&gt;' + data.postalcodes[0].adminName2 + ', ' + data.postalcodes[0].adminName1 + '&lt;/h4&gt;&lt;/li&gt;');
  },
  // 5 second timeout:
  timeout: 5000
});
</code></pre>

<p>Deferred versions:</p>

<pre class="prettyprint"><code>.JSONP({
  url: 'https://api.github.com/users/yui?callback=?'
})
.done(function(lib) {
  $('.list').append('&lt;li&gt;&lt;h3&gt;The name of the library&lt;/h3&gt;&lt;h4&gt;' + lib.data.name + '&lt;/h4&gt;&lt;/li&gt;');
});

.JSONP({
  url: 'https://api.github.com/users/yui?callback=?',
  timeout: 5000
})
.done(function(lib) {
  $('.list').append('&lt;li&gt;&lt;h3&gt;The name of the library&lt;/h3&gt;&lt;h4&gt;' + lib.data.name + '&lt;/h4&gt;&lt;/li&gt;');
})
.fail(function(msg, settings) {
  console.log(msg);
  console.log('There was a problem connecting to: ' + settings.url);
});
</code></pre>





<h3>
<a name="cc-form2json" class="anchor" href="#form2json" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.form2JSON</h3>

<p>This method converts form values into a JSON object. This can be converted to a string for sending to the server with a GET or POST request, or stored on the client side in localStorage or the client side SQLite database.</p>

<p>It expects two parameters:</p>

<p>selector: a valid selector for the form to be processed.
delimiter: a character to use as a delimiter for the marking of JSON member relations in the form elements name values (see example below). This defaults to ., but you can use any other character that suits your purposes.
For this method to work properly you must name all form elements that you want to retrieve so that they match the structure of the resulting JSON object you would like. You use . to indicate the sub objects of the JSON object. For example, if your form was for signing up a user, you might have inputs with names such as:</p>

<pre class="prettyprint"><code>&lt;form id="newUser"&gt;
  &lt;input type="text" name="newUser.name.first"&gt;&lt;/input&gt;
  &lt;input type="text" name="newUser.name.last"&gt;&lt;/input&gt;
  &lt;input type="text" name="newUser.address.street"&gt;&lt;/input&gt;
  &lt;input type="text" name="newUser.address.city"&gt;&lt;/input&gt;
  &lt;input type="text" name="newUser.address.state"&gt;&lt;/input&gt;
  &lt;input type="text" name="newUser.address.zip"&gt;&lt;/input&gt;
  &lt;input type="text" name="newUser.phone"&gt;&lt;/input&gt;
  &lt;input type="text" name="newUser.email"&gt;&lt;/input&gt;
 &lt;/form&gt;

{"newUser":
  {"name":
    {"first": "someValueHere"},
    {"last": "someValueHere"}
  },
  {"address":
    {"street": "someValueHere"},
    {"city": "someValueHere"},
    {"state": "someValueHere"},
    {"zip": "someValueHere"}
  },
  {"phone": "someValueHere" },
  {"email": "someValueHere"}
}
</code></pre>

<p>Disabled form elements or ones which have no value will be ignored.</p>

<p>If you need to create an array from something like a set of choices, youll need to marke the name with brackets [] to indicate that its an array:</p>

<pre class="prettyprint"><code>&lt;div&gt;Favorite food&lt;/div&gt;
&lt;p&gt;
  &lt;label&gt;Salad:&lt;/label&gt;
  &lt;input type="checkbox" name="user.favoriteFood[]" value="salad"&gt;
&lt;/p&gt;
&lt;p&gt;
  &lt;label&gt;Pizza:&lt;/label&gt;
  &lt;input type="checkbox" name="user.favoriteFood[]" value="pizza"&gt;
&lt;/p&gt;
&lt;p&gt;
  &lt;label&gt;Chicken:&lt;/label&gt;
  &lt;input type="checkbox" name="user.favoriteFood[]" value="chicken"&gt;
&lt;/p&gt;
</code></pre>

<h2>
<a name="cc-templates" class="anchor" href="#templates" aria-hidden="true"><span class="octicon octicon-link"></span></a>Templates</h2>

<p>ChocolateChipJS provides its own means of implementing templates. These can be string-based, or script tags or external files.</p>

<h3>
<a name="cc-templates-2" class="anchor" href="#templates-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.templates</h3>

<p>This is a cache for storing your templates. This makes it easy to retrieve your template for reuse later on.</p>

<pre class="prettyprint"><code>$.template.myTemplate = '&lt;li&gt;Name: [[= data.name]]&lt;/li&gt;';
</code></pre>

<p>Then you could just do this:</p>

<pre class="prettyprint"><code>var parsedTemplate = $.template($.template.myTemplate);
$('#user').html(parsedTemplate(userInfo));
</code></pre>

<p>You could also use <code>$.template</code> to store parsed templates. Then you could use them at any time in your application:</p>

<pre class="prettyprint"><code>$.template.myTemplate = $.template('&lt;li&gt;Name: [[= data.name]]&lt;/li&gt;');

// Later:
$('#user').html($.template.myTemplate(userInfo));

</code></pre>

<h3>
<a name="cc-template" class="anchor" href="#template" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.template</h3>

<p>This method allows you to parse templates and render them with data. You can use it to store string templates, or parsed templates ready to pass data to.</p>

<p>ChocolateChipJS uses square brackets as delimiters.Matching sets of square brackets are used to mark off JavaScript code. To render a JavaScript variable, you use include the "=" sign as part of the first block of square brackets. Notice how the data object the template consumes is designated by the term <code>data</code>.</p>

<pre class="prettyprint"><code>var myTemplate = '&lt;li id="name"&gt;My Name: [[= data.name ]].&lt;/li&gt;\
  &lt;li&gt;My age: [[= data.age ]].&lt;/li&gt;\
  &lt;li&gt;Job: [[= data.job ]].&lt;/li&gt;\
  &lt;li&gt;Current Salary: [[= data.salary ]].&lt;/li&gt;\
  [[ for (var i = 0, l = 3; i &lt; l; i++) { ]]\
     [[ console.log("'i' is: " + i); ]]\
  [[ } ]]';

var userInfo = {
  name: 'Wobba',
  age: 100,
  job: 'Rocket Scientist',
  salary: '$1,000,000,000'
};

// Parse the template:
var parsedTempl8 = $.template(myTemplate);

// Pass data to the template and insert it in the document:
$('#user').html(parsedTempl8(userInfo));
</code></pre>

<h2><a name="cc-template-repeater" class='anchor' href='#template_repeater' aria-hidden="true"><span class="octicon octicon-link"></span></a>$.template.repeater</h2>

<p>This method enables you to output a template repeatedly based on the value of an array of data. This method can take two types of arrays: simple or consisting of objects. Using other data types will throw and error. You could use either of the following types of arrays:</p>

<pre class="prettyprint"><code>var simpleArray = ["one", "two", "three", "four", "five"];
var arrayOfObjects = [
  {firstName: "John, lastName: "Doe", age: 22},
  {firstName: "Suzy", lastName: "Que", age: 21},
  {firstName: "Joe", lastName: "Bodoni", age: 30}
];
</code></pre>

<p><code>$.template.repeater</code> takes three arguments:</p>

<ul>
  <li>element: the target in which the result will go</li>
  <li>template: the template to repeat</li>
  <li>data: an array of repeatable data</li>
</ul>

<p>Below are two examples of how to use <code>$.template.repeater</code>:</p>

<pre class="prettyprint"><code>&lt;body&gt;
  &lt;ol id='arrayList'&gt;
  &lt;/ol&gt;
  &lt;ul id="objectArrayList"&gt;&lt;/ul&gt;
&lt;/body&gt;

/* The JavaScript: */
$(function() {
  // Output a simple array of data:
  var simpleArray = ['One','Two', 'Three', 'Four', 'Five'];
  var repeaterTmplate1 = '&lt;li&gt;[[= data ]]&lt;/li&gt;';
  $.template.repeater($('#arrayList'), repeaterTmplate1, simpleArray);

  // Output an array of objects:
  var luminaries = { persons: 
    [
      {firstName: "Albert", lastName: "Einstein"},
      {firstName: "Steven", lastName: "Hawking"},
      {firstName: "Neil", lastName: "deGrasse Tyson"},
      {firstName: "Leonardo", lastName: "Da Vinci"},
      {firstName: "Nicholas", lastName: "Copernicus"}  
    ]
  };
  var repeaterTmplate2 = '&lt;li&gt;[[= data.firstName ]], [[= data.lastName]]&lt;/li&gt;';
  // Pass in the array of persons:
  $.template.repeater($('#objectArrayList'), repeaterTmplate2, luminaries.persons);
});
</code></pre>

<p>This will produce the following:</p>

<pre class="prettyprint"><code>&lt;ol id="arrayList"&gt;
  &lt;li&gt;One&lt;/li&gt;
  &lt;li&gt;Two&lt;/li&gt;
  &lt;li&gt;Three&lt;/li&gt;
  &lt;li&gt;Four&lt;/li&gt;
  &lt;li&gt;Five&lt;/li&gt;
&lt;/ol&gt;
&lt;ul id="objectArrayList"&gt;
  &lt;li&gt;Albert, Einstein&lt;/li&gt;
  &lt;li&gt;Steven, Hawking&lt;/li&gt;
  &lt;li&gt;Neil, deGrasse Tyson&lt;/li&gt;
&lt;/ul&gt;</code></pre>


<p><strong>Behavior:</strong> By default, $.template.repeater appends its results to the target element. If you want it to replace the contents, then simple use <code>$(selector).empty()</code> before executing <code>$.template.repeater()</code></p>


<h2><a name="cc-declarative-repeater" class='anchor' href='#declarative_repeater' aria-hidden="true"><span class="octicon octicon-link"></span></a>Declarative Template Repeater</h2>

<p>ChocolateChip-UI also provides a way to use declarative repeater templates. You do this by putting the attribute <code>data-repeat</code> with its value being the name of a variable of the array of data you want it to render with. Because of the way JavaScript scopes work, you need to expose the data to the template engine so that it can parse the template with it. You do this by assigning it to <code>$.template.data</code>:</p>

<pre class="prettyprint"><code>// Define some data:
var renaissanceLuminaries = { persons: 
  [
    {firstName: "Albert", lastName: "Einstein"},
    {firstName: "Steven", lastName: "Hawking"},
    {firstName: "Neil", lastName: "deGrasse Tyson"},
    {firstName: "Leonardo", lastName: "Da Vinci"},
    {firstName: "Nicholas", lastName: "Copernicus"}  
  ]
};
// Expose the data to the $.template.data object:
$.template.data['luminaries'] = renaissanceLuminaries.persons;
</code></pre>

<p>Don't worry about this duplicating your data and taking up memory. After the template gets rendered, ChocolateChip-UI will delete the data object so that its memory gets garbage collected.</p>

<p>Setting up a declarative template repeater is simple:</p>
<pre class="prettyprint"><code>&lt;ul id="repeater" data-repeater="luminaries" class='cloak'&gt;
  &lt;li&gt;[[= data.firstName ]], [[= data.lastName]]&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>With the template defined and our data assigned to the <code>$.template.data</code> object, we can invoke the repeater method. We do without passing any parameters. Every time you do so, it will search your document for declarative repeaters, so be careful to only do it when all templates have their data ready for render, because after rendering, that data gets deleted from the template data object.</p>
<pre class="prettyprint"><code>// Parse any declarative repeaters:
$.template.repeater();
</code></pre>

<p><strong>Note:</strong> You can keep the unrendered template of the declarative repeater from showing by putting the class "cloak" on it. You can see that class on the repeat above. This class hides the child elements of the repeater. When ChocolateChip-UI renders the repeater, it takes this class off before injecting the repetitive content into it.</p>

<h2><a name="cc-template-index" class='anchor' href='#template_index' aria-hidden="true"><span class="octicon octicon-link"></span></a>$.template.index</h2>

<p>When using a repeater, you may need to know what iteration your own, say, to output a numberic value. ChocolateChip-UI templates provides a way for you to do this using <code>$.template.index</code>. Like other JavaScript loop processes, it starts with 0 and increases after that. So, if you want to output numbers, you'll need to increase them by 1. Here's an example:</p>

<pre class="prettyprint"><code>&lt;ul id="repeater" data-repeater="luminaries" class='cloak'&gt;
  &lt;li&gt;[[= $.template.index + 1 ]]: [[= data.firstName ]], [[= data.lastName]]&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>This would create the following markup:</p>

<pre class="prettyprint"><code>&lt;ul id="luminaries"&gt;
  &lt;li&gt;1: Albert, Einstein&lt;/li&gt;
  &lt;li&gt;2: Steven, Hawking&lt;/li&gt;
  &lt;li&gt;3: Neil, deGrasse Tyson&lt;/li&gt;
&lt;/ul&gt;</code></pre>

<p><strong>Note:</strong> One last thing to bear in mind. Because template variables are actually JavaScript variables, you can perform any appropriate JavaScript operations directly on them. We are already doing that by increase the value of the <code>$.template.index</code> by 1 in each loop in the template above. Or you might want to do something such as capitalizing the last name using <code>String.toUpperCase()</code>:</p>

<pre class="prettyprint"><code>&lt;ul id="repeater" data-repeater="luminaries" class='cloak'&gt;
  &lt;li&gt;[[= $.template.index + 1 ]]: [[= data.firstName ]], [[= data.lastName.toUpperCase() ]]&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<h2>
<a name="cc-pubsub" class="anchor" href="#pubsub" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pub/Sub</h2>

<p>Pub/sub is a useful programming pattern to help decouple code. This allows you to set up methods that "subscribe" to a topic, something like a radio channel. When you publish data to a topic, all methods that are subscribed to that topic will execute with that data. It thus provides an easy way to pass the same data to multiple functions without having to enclose them in one function.</p>

<p>When implementing a pub/sub pattern, be careful not to over use it, as it can sometimes be difficult to debug or run tests against.</p>

<h3>
<a name="cc-subscriptions" class="anchor" href="#subscriptions" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.subscriptions</h3>

<p>The is a cache for all subscriptions. If you unsubscribe for a topic, the subscription will be removed.</p>

<p>By convention, topics used for subscriptions use forward slashes to demark namespaces, something like a rest interface.</p>

<pre class="prettyprint"><code>// Possible topics:
'user/new'
'user/current'
'purchases/songs'
'purchases/apps'
</code></pre>

<h3>
<a name="cc-subscribe" class="anchor" href="#subscribe" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.subscribe</h3>

<p>To subscribe to a topic, you pass two arguments, a topic and a callback to execute when data gets published. It's a good idea to put in some data checks to see what kind of data is being received. That way you can choose not to do anything, or to use only certain parts of the data. The type of data could be any valid JavaScript type: string, array, object, etc. It's up to you to figure out where this data that you publish comes from. It might reside on the server, it could be dynamically generated by the server. It might come from any number of possible sources: Ajax requests, Web services, etc.</p>

<p>Below is an example of how to subscribe to a topic:</p>

<pre class="prettyprint"><code>var arraySubscriber = function( data ){
  $('.list').append('&lt;li&gt;&lt;h3&gt;' + topic + '&lt;/h3&gt;&lt;h4&gt;' + data + '&lt;/h4&gt;&lt;/li&gt;');
var newsSubscription = $.subscribe( 'news/update', arraySubscriber );
};
</code></pre>

<h3>
<a name="cc-publish" class="anchor" href="#publish" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.publish</h3>

<p>The $.publish() method lets you send data to all topics that are subscribed to a topic.</p>

<pre class="prettyprint"><code>$.publish('news/update', 'The New York Stock Exchange rose an unprecedented 1000 points in just three minutes. Analysts and investors are confused and uncertain how to respond.');
</code></pre>

<h3>
<a name="cc-unsubscribe" class="anchor" href="#unsubscribe" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.unsubscribe</h3>

<p>After setting up a subscription to a topic, you may want to unsubscribe when certain conditions occur. You can do this with the $.unsubscribe() method. Just pass it the name to the subscription you set up, that would be one with a topic and callback as its arguments. See below:</p>

<pre class="prettyprint"><code>$.unsubscribe(newsSubscription);
</code></pre>

<p>After unsubscribing from a topic, any further attempts to publish data to the method will do nothing.</p>

<pre class="prettyprint"><code>var arraySubscriber = function(data) {
  $('.list').append('&lt;li&gt;&lt;h3&gt;' + topic + '&lt;/h3&gt;&lt;h4&gt;' + data + '&lt;/h4&gt;&lt;/li&gt;');
var newsSubscription = $.subscribe('news/update', arraySubscriber);
};
// This news item gets published:
$.publish( 'news/update', 'The New York Stock Exchange rose an unprecedented 1000 points in just three minutes. Analysts and investors are confused and uncertain how to respond.' );
$.unsubscribe(newsSubscription);
// Due to being unsubscribed above, this does nothing:
$.publish('news/update', 'We have nothing further to comment at this time.');
</code></pre>

<h2>
<a name="cc-deferred-object" class="anchor" href="#deferred-object" aria-hidden="true"><span class="octicon octicon-link"></span></a>Deferred Object</h2>

<p>The default build of ChocolateChipJS provides a Deferred object, but using a flag, you can build a version of ChocolateChipJS that instead uses ECMAScript promises. The documentation for promises comes after this section.</p>

<p>The Deferred object is a chainable utility object created by calling the <code>$.Deferred()</code> method. It can register multiple callbacks into callback queues, invoke callback queues, and relay the success or failure state of any synchronous or asynchronous function. This implementation is based on the version in jQuery 1.7. Please examine the example and unit tests to see how to use it.</p>

<p>The Deferred object is chainable, similar to the way ChocolateChip methods are chainable, but it has its own methods. After creating a Deferred object, you can use any of the methods below by either chaining directly from the object creation or saving the object in a variable and invoking one or more methods on that variable.</p>

<ul>
<li>$.Deferred()</li>
<li>done()</li>
<li>fail()</li>
<li>always()</li>
<li>pipe()</li>
<li>progress()</li>
<li>notify()</li>
<li>notifyWith()</li>
<li>state()</li>
<li>isResolved()</li>
<li>isRejected()</li>
<li>resolve()</li>
<li>resolveWith()</li>
<li>reject()</li>
<li>rejectWith()</li>
<li>then()</li>
<li>when()</li>
</ul><h3>
<a name="cc-deferred" class="anchor" href="#deferred" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.Deferred</h3>

<p>A constructor function that returns a chainable utility object with methods to register multiple callbacks into callback queues, invoke callback queues, and relay the success or failure state of any synchronous or asynchronous function.</p>

<p>The $.Deferred method can be passed an optional function, which is called just before the constructor returns and is passed the constructed deferred object as both the this object and as the first argument to the function. The called function can attach callbacks using <code>deferred.then()</code>, for example.</p>

<p>A Deferred object starts in the pending state. Any callbacks added to the object with <code>deferred.then()</code>, <code>deferred.always()</code>, <code>deferred.done()</code>, or <code>deferred.fail()</code> are queued to be executed later. Calling <code>deferred.resolve()</code> or <code>deferred.resolveWith()</code> transitions the Deferred into the resolved state and immediately executes any doneCallbacks that are set. Calling <code>deferred.reject()</code> or <code>deferred.rejectWith()</code> transitions the Deferred into the rejected state and immediately executes any failCallbacks that are set. Once the object has entered the resolved or rejected state, it stays in that state. Callbacks can still be added to the resolved or rejected Deferred  they will execute immediately.</p>

<p>Enhanced Callbacks with $.Deferred</p>

<p>In JavaScript it is common to invoke functions that optionally accept callbacks that are called within that function.</p>

<p>$.Deferred() introduces several enhancements to the way callbacks are managed and invoked. In particular, $.Deferred() provides flexible ways to provide multiple callbacks, and these callbacks can be invoked regardless of whether the original callback dispatch has already occurred.</p>

<p>One model for understanding Deferred is to think of it as a chain-aware function wrapper. The <code>deferred.then()</code>, <code>deferred.always()</code>, <code>deferred.done()</code>, and <code>deferred.fail()</code> methods specify the functions to be called and the deferred.resolve(args) or deferred.reject(args) methods "call" the functions with the arguments you supply. Once the Deferred has been resolved or rejected it stays in that state; a second call to <code>deferred.resolve()</code>, for example, is ignored. If more functions are added by <code>deferred.then()</code>, for example, after the Deferred is resolved, they are called immediately with the arguments previously provided.</p>

<pre class="prettyprint"><code>var deferred = new $.Deferred();

// or without the new keyword:

var deferred = $.Deferred();
</code></pre>

<h3>
<a name="cc-done" class="anchor" href="#done" aria-hidden="true"><span class="octicon octicon-link"></span></a>done</h3>

<p>Add handlers to be called when the Deferred object is resolved. The argument can be a function, or array of functions, that is called when the Deferred is resolved or rejected.</p>

<p>The <code>deferred.done()</code> method accepts one or more arguments, all of which can be either a single function or an array of functions. When the Deferred is resolved, the doneCallbacks are called. Callbacks are executed in the order they were added. Since <code>deferred.done()</code> returns the deferred object, other methods of the deferred object can be chained to this one, including additional <code>.done()</code> methods. When the Deferred is resolved, doneCallbacks are executed using the arguments provided to the resolve or resolveWith method call in the order they were added.</p>

<pre class="prettyprint"><code>&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;deferred.done demo&lt;/title&gt;
  &lt;script src="chui/chocolatechip.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;button&gt;Go&lt;/button&gt;
&lt;p&gt;Ready...&lt;/p&gt;

&lt;script&gt;
// 3 functions to call when the Deferred object is resolved
function fn1() {
  $( "p" ).append( " 1 " );
}
function fn2() {
  $( "p" ).append( " 2 " );
}
function fn3( n ) {
  $( "p" ).append( n + " 3 " + n );
}

// Create a deferred object
var dfd = $.Deferred();

// Add handlers to be called when dfd is resolved
dfd
// .done() can take any number of functions or arrays of functions
  .done( [ fn1, fn2 ], fn3, [ fn2, fn1 ] )
// We can chain done methods, too
  .done(function( n ) {
    $( "p" ).append( n + " we're done." );
  });

// Resolve the Deferred object when the button is clicked
$( "button" ).on( "click", function() {
  dfd.resolve( "and" );
});
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3>
<a name="cc-fail" class="anchor" href="#fail" aria-hidden="true"><span class="octicon octicon-link"></span></a>fail</h3>

<p>Add handlers to be called when the Deferred object is rejected. The argument can be a function, or array of functions, that is called when the Deferred is resolved or rejected.</p>

<p>The <code>deferred.fail()</code> method accepts one or more arguments, all of which can be either a single function or an array of functions. When the Deferred is rejected, the failCallbacks are called. Callbacks are executed in the order they were added. Since <code>deferred.fail()</code> returns the deferred object, other methods of the deferred object can be chained to this one, including additional <code>deferred.fail()</code> methods. The failCallbacks are executed using the arguments provided to the <code>deferred.reject()</code> or <code>deferred.rejectWith()</code> method call in the order they were added.</p>

<pre class="prettyprint"><code>// Create a deferred object
var dfd = $.Deferred();

dfd.done(/* Do stuff when done */).fail(/* Do stuff when fail */);
</code></pre>

<h3>
<a name="cc-always" class="anchor" href="#always" aria-hidden="true"><span class="octicon octicon-link"></span></a>always</h3>

<p>Add handlers to be called when the Deferred object is either resolved or rejected. The argument can be a function, or array of functions, that is called when the Deferred is resolved or rejected.</p>

<p>The argument can be either a single function or an array of functions. When the Deferred is resolved or rejected, the callbacks are called. Since <code>deferred.always()</code> returns the Deferred object, other methods of the Deferred object can be chained to this one, including additional <code>.always()</code> methods. When the Deferred is resolved or rejected, callbacks are executed in the order they were added, using the arguments provided to the resolve, reject, resolveWith or rejectWith </p>

<pre class="prettyprint"><code>// Create a deferred object
var dfd = $.Deferred();
dfd
  .done(/* Do stuff when done */)
  .fail(/* Do stuff when fail */)
  .always(/* This will always execute for done and fail */);
</code></pre>

<h3>
<a name="cc-pipe" class="anchor" href="#pipe" aria-hidden="true"><span class="octicon octicon-link"></span></a>pipe</h3>

<p>Utility method to filter and/or chain Deferreds. It accepts two arguments. The first is <code>doneFilter</code> that is called when the Deferred is resolved. The second is <code>failFilter</code> that is called when the Deferred is rejected.</p>

<p>The <code>deferred.pipe()</code> method returns a new promise that filters the status and values of a deferred through a function. The <code>doneFilter</code> and <code>failFilter</code> functions filter the original Deferred's resolved / rejected status and values. If the filter function used is null, or not specified, the piped promise will be resolved or rejected with the same values as the original.</p>

<h4>
<a name="cc-filter-resolve-example" class="anchor" href="#filter-resolve-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Filter resolve example:</h4>

<pre class="prettyprint"><code>var defer = $.Deferred();
var filtered = defer.pipe(function( value ) {
  return value * 2;
});

defer.resolve( 5 );
filtered.done(function( value ) {
  alert( "Value is ( 2*5 = ) 10: " + value );
});  
</code></pre>

<h4>
<a name="cc-filter-reject-example" class="anchor" href="#filter-reject-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Filter reject example:</h4>

<pre class="prettyprint"><code>var defer = $.Deferred(),
filtered = defer.pipe( null, function( value ) {
  return value * 3;
});

defer.reject( 6 );
filtered.fail(function( value ) {
  alert( "Value is ( 3*6 = ) 18: " + value );
});
</code></pre>

<h3>
<a name="cc-progress" class="anchor" href="#progress" aria-hidden="true"><span class="octicon octicon-link"></span></a>progress</h3>

<p>Add handlers to be called when the Deferred object generates progress notifications. It is executed from the object onto which the promise methods have to be attached.</p>

<p>The <code>deferred.promise()</code> method allows an asynchronous function to prevent other code from interfering with the progress or status of its internal request. The promise exposes only the Deferred methods needed to attach additional handlers or determine the state (then, done, fail, always, pipe, progress, and state), but not ones that change the state (resolve, reject, notify, resolveWith, rejectWith, and notifyWith).</p>

<p>If target is provided, <code>deferred.promise()</code> will attach the methods onto it and then return this object rather than create a new one. This can be useful to attach the promise behavior to an object that already exists.</p>

<p>If you are creating a Deferred, keep a reference to the Deferred so that it can be resolved or rejected at some point. Return only the promise object via <code>deferred.promise()</code> so other code can register callbacks or inspect the current state.</p>

<pre class="prettyprint"><code>var dfd = $.Deferred();
// Do some stuff with dfd, 
// then do something as it progresses:
dfd.progress(function(value1, value2) {
  equal(value1, param1, 'Should equal param1.');
  equal(value2, param2, 'Should equal param2.');
  return equal(this, context, 'Should be the context.');
});
</code></pre>

<h3>
<a name="cc-notify" class="anchor" href="#notify" aria-hidden="true"><span class="octicon octicon-link"></span></a>notify</h3>

<p>Call the <code>progressCallbacks</code> on a Deferred object with the given args. Optional arguments are an object that is passed to the <code>progressCallbacks</code>.</p>

<p>Normally, only the creator of a Deferred should call this method; you can prevent other code from changing the Deferred's state or reporting status by returning a restricted promise object through <code>deferred.promise()</code>.</p>

<p>When <code>deferred.notify</code> is called, any <code>progressCallbacks</code> added by <code>deferred.then</code> or <code>deferred.progress</code> are called. Callbacks are executed in the order they were added. Each callback is passed the args from the <code>deferred.notify()</code>. Any calls to <code>deferred.notify()</code> after a Deferred is resolved or rejected (or any <code>progressCallbacks</code> added after that) are ignored. For more information, see the documentation for Deferred object.</p>

<pre class="prettyprint"><code>var context, def, param1, param2, progressCalled;
def = new $.Deferred();
context = new Array();
param1 = 'foo';
param2 = 'bar';
progressCalled = 0; 
def.progress(function(value1, value2) {
  progressCalled += 1;
  equal(value1, param1, 'Should equal param1.');
  equal(value2, param2, 'Should equal param2.');
  return equal(this, context, 'Should be the context.');
});
def.notifyWith(context, param1, param2);
equal(progressCalled, 2, 'Should equal 2.');
def.resolve();
def.notify();
</code></pre>

<h3>
<a name="cc-notifywith" class="anchor" href="#notifywith" aria-hidden="true"><span class="octicon octicon-link"></span></a>notifyWith</h3>

<p>Call the <code>progressCallbacks</code> on a Deferred object with the given context and args.</p>

<p>Normally, only the creator of a Deferred should call this method; you can prevent other code from changing the Deferred's state or reporting status by returning a restricted promise object through <code>deferred.promise()</code>.</p>

<p>When <code>deferred.notifyWith</code> is called, any <code>progressCallbacks</code> added by <code>deferred.then</code>or <code>deferred.progress</code> are called. Callbacks are executed in the order they were added. Each callback is passed the args from the <code>deferred.notifyWith()</code>. Any calls to <code>deferred.notifyWith()</code> after a Deferred is resolved or rejected (or any <code>progressCallbacks</code> added after that) are ignored. For more information, see the documentation for Deferred object.</p>

<p>See example for <code>notify</code> above.</p>

<h3>
<a name="cc-state" class="anchor" href="#state" aria-hidden="true"><span class="octicon octicon-link"></span></a>state</h3>

<p>Determine the current state of a Deferred object.</p>

<p>"pending": The Deferred object is not yet in a completed state (neither "rejected" nor "resolved").
"resolved": The Deferred object is in the resolved state, meaning that either <code>deferred.resolve()</code> or <code>deferred.resolveWith()</code> has been called for the object and the doneCallbacks have been called (or are in the process of being called).
"rejected": The Deferred object is in the rejected state, meaning that either <code>deferred.reject()</code> or <code>deferred.rejectWith()</code> has been called for the object and the failCallbacks have been called (or are in the process of being called).
This method is primarily useful for debugging to determine, for example, whether a Deferred has already been resolved even though you are inside code that intended to reject it.</p>

<p>You can use this to check the state of the deferred object and take some action based on it. You might use a switch state to test for the states you are interested in.</p>

<pre class="prettyprint"><code>var dfd = $.Deferred();

// Do some stuff with dfd.
// Log its state:
console.log(dfd.state());
</code></pre>

<h3>
<a name="cc-isresolved" class="anchor" href="#isresolved" aria-hidden="true"><span class="octicon octicon-link"></span></a>isResolved</h3>

<p><code>deferred.isResolved()</code> is used to determine whether a Deferred object has been resolved. This method does not accept any arguments. This is a convenience method for getting this value from the <code>state</code> method described above. </p>

<p>Returns true if the Deferred object is in the resolved state, meaning that either <code>deferred.resolve()</code> or <code>deferred.resolveWith()</code> has been called for the object and the <code>doneCallbacks</code> have been called (or are in the process of being called).</p>

<p>Note that a Deferred object can be in one of three states: pending, resolved, or rejected; use <code>deferred.isRejected()</code> to determine whether the Deferred object is in the rejected state. These methods are primarily useful for debugging, for example to determine whether a Deferred has already been resolved even though you are inside code that intended to reject it.</p>

<h3>
<a name="cc-isrejected" class="anchor" href="#isrejected" aria-hidden="true"><span class="octicon octicon-link"></span></a>isRejected</h3>

<p><code>deferred.isRejected()</code> is used to determine whether a Deferred object has been rejected. This method does not accept any arguments. This is a convenience method for getting this value from the <code>state</code> method described above. </p>

<p>Returns true if the Deferred object is in the rejected state, meaning that either <code>deferred.reject()</code> or <code>deferred.rejectWith()</code> has been called for the object and the failCallbacks have been called (or are in the process of being called).</p>

<p>Note that a Deferred object can be in one of three states: pending, resolved, or rejected; use <code>deferred.isResolved()</code> to determine whether the Deferred object is in the resolved state. These methods are primarily useful for debugging, for example to determine whether a Deferred has already been resolved even though you are inside code that intended to reject it.</p>

<h3>
<a name="cc-resolve" class="anchor" href="#resolve" aria-hidden="true"><span class="octicon octicon-link"></span></a>resolve</h3>

<p>Resolve a Deferred object and call any <code>doneCallbacks</code> with the given args.</p>

<pre class="prettyprint"><code>var dfd = $.Deferred();
// Do stuff with the deferred.
dfd.done(function() {/* Do stuff here */});
// Resolve the deferred, which will 
// cause dfd.done to execute:
dfd.resolve();
</code></pre>

<h3>
<a name="cc-resolvewith" class="anchor" href="#resolvewith" aria-hidden="true"><span class="octicon octicon-link"></span></a>resolveWith</h3>

<p>Resolve a Deferred object and call any <code>doneCallbacks</code> with the given context and args. It accepts an optional array of arguments that are passed to the <code>doneCallbacks</code>.</p>

<p>Normally, only the creator of a Deferred should call this method; you can prevent other code from changing the Deferred's state by returning a restricted promise object through <code>deferred.promise()</code>.</p>

<p>When the Deferred is rejected, any <code>doneCallbacks</code> added by <code>deferred.then</code> or <code>deferred.fail</code> are called. Callbacks are executed in the order they were added. Each callback is passed the args from the <code>deferred.reject()</code> call. Any <code>doneCallbacks</code> added after the Deferred enters the rejected state are executed immediately when they are added, using the arguments that were passed to the <code>deferred.reject()</code> call.</p>

<pre class="prettyprint"><code>var context = ["one","two","three"];
var defer = new $.Deferred(); 
defer
  .done(function() {
    console.log('This has been resolved!');
    context.forEach(function(ctx) {
      console.log(ctx);
    });
  });
  .fail(function() {
    console.log('This has failed!');
  });

// Resolve the deferred and pass
// the array as the context:
defer.resolveWith(context);

// outputs:
// "This has been resolved!"
// "one"
// "two"
// "three"

</code></pre>

<h3>
<a name="cc-reject" class="anchor" href="#reject" aria-hidden="true"><span class="octicon octicon-link"></span></a>reject</h3>

<p>Reject a Deferred object and call any <code>failCallbacks</code> with the given args. It accpets optional arguments that are passed to the <code>failCallbacks</code>.</p>

<p>Normally, only the creator of a Deferred should call this method; you can prevent other code from changing the Deferred's state by returning a restricted promise object through <code>deferred.promise()</code>.</p>

<p>When the Deferred is rejected, any <code>failCallbacks</code> added by <code>deferred.then()</code> or <code>deferred.fail()</code> are called. Callbacks are executed in the order they were added. Each callback is passed the args from the <code>deferred.reject()</code> call. Any <code>failCallbacks</code> added after the Deferred enters the rejected state are executed immediately when they are added, using the arguments that were passed to the <code>deferred.reject()</code> call.</p>

<pre class="prettyprint"><code>var context = ["one","two","three"];
var defer = new $.Deferred(); 
defer
  .done(function() {
    console.log('This has been resolved!');
  });
  .fail(function() {
    console.log('This was rejected!')
  });

// Reject the deferred:
defer.reject();

// outputs:
// "This was rejected!"

</code></pre>

<h3>
<a name="cc-rejectwith" class="anchor" href="#rejectwith" aria-hidden="true"><span class="octicon octicon-link"></span></a>rejectWith</h3>

<p>Reject a Deferred object and call any <code>failCallbacks with</code> the given context and args. This works just like <code>deferred.resolveWith</code>, except that <code>failCallbacks</code> are executed instead of <code>doneCallbacks</code>.</p>

<pre class="prettyprint"><code>var context = ["one","two","three"];
var defer = new $.Deferred(); 
defer
  .done(function() {
    console.log('This has been resolved!');
    context.forEach(function(ctx) {
      console.log(ctx);
    });
  });
  .fail(function() {
    console.log('This was rejected!');
    console.log('The array has ' + context.length + ' items.')
  });

// Resolve the deferred and pass
// the array as the context:
defer.rejectWith(context);

// outputs:
// "This was rejected"
// "The array has 3 items."
</code></pre>

<h3>
<a name="cc-then" class="anchor" href="#then" aria-hidden="true"><span class="octicon octicon-link"></span></a>then</h3>

<p>Add handlers to be called when the Deferred object is resolved, rejected, or still in progress. It accepts the following arguments in order:</p>

<ul>
<li>doneCallbacks: A function, or array of functions, called when the Deferred is resolved.</li>
<li>failCallbacks: A function, or array of functions, called when the Deferred is rejected.</li>
<li>progressCallbacks: A function, or array of functions, called when the Deferred notifies progress.</li>
</ul><p>Callbacks are executed in the order they were added. Since deferred.then returns a promise, other methods of the promise object can be chained to this one, including additional <code>deferred.then()</code> methods.</p>

<pre class="prettyprint"><code>&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;deferred.then demo&lt;/title&gt;
  &lt;script src="chui/chocolatechip.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;button&gt;Filter Resolve&lt;/button&gt;
&lt;p&gt;&lt;/p&gt;

&lt;script&gt;
var filterResolve = function() {
  var defer = $.Deferred(),
    filtered = defer.then(function( value ) {
      return value * 2;
    });

  defer.resolve( 5 );
  filtered.done(function( value ) {
    $( "p" ).html( "Value is ( 2*5 = ) 10: " + value );
  });
};

$( "button" ).on( "click", filterResolve );
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3>
<a name="cc-when" class="anchor" href="#when" aria-hidden="true"><span class="octicon octicon-link"></span></a>when</h3>

<p>This provides a way to execute callback functions based on one or more objects, usually Deferred objects that represent asynchronous events. It accepsts one or more Deferred objects, or plain JavaScript objects.</p>

<p>If a single Deferred is passed to <code>$.when</code>, its promise object (a subset of the Deferred methods) is returned by the method. Additional methods of the promise object can be called to attach callbacks, such as <code>deferred.then</code>. When the Deferred is resolved or rejected, usually by the code that created the Deferred originally, the appropriate callbacks will be called.</p>

<p>If a single argument is passed to <code>$.when</code> and it is not a Deferred or a promise, it will be treated as a resolved Deferred and any <code>doneCallbacks</code> attached will be executed immediately. The <code>doneCallbacks</code> are passed the original argument. In this case any <code>failCallbacks</code> you might set are never called since the Deferred is never rejected. For example:</p>

<pre class="prettyprint"><code>$.when( { testing: 123 } ).done(function( x ) {
   alert( x.testing ); // Alerts "123"
});
</code></pre>

<p>In the case where multiple Deferred objects are passed to $.when, the method returns the promise from a new "master" Deferred object that tracks the aggregate state of all the Deferreds it has been passed. The method will resolve its master Deferred as soon as all the Deferreds resolve, or reject the master Deferred as soon as one of the Deferreds is rejected. If the master Deferred is resolved, it is passed the resolved values of all the Deferreds that were passed to $.when.</p>

<p>In the multiple Deferreds case where one of the Deferreds is rejected, $.when immediately fires the <code>failCallbacks</code> for its master Deferred. Note that some of the Deferreds may still be unresolved at that point.</p>

<pre class="prettyprint"><code>$.when(asyncEvent()).then(
  function(status){
    alert(status + ' Things are going well.');
    document.getElementById('foo').style.backgroundColor = 'green';
  },
  function(status){
    alert(status + ' You fail this time.');
    document.getElementById('foo').style.backgroundColor = 'red';
  }
);

// another example
function showDiv(){
  var dfd = $.Deferred();
  dfd.done(function(){
    document.getElementById('foo').style.display = 'block';
  });
  setTimeout(function() { dfd2.resolve() }, 2000);
  return dfd2.promise();
}
showDiv();
</code></pre>



<h2>
<a name="cc-animation" class="anchor" href="#animation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Animation</h2>

<h3>
<a name="cc-animate" class="anchor" href="#animate" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.animate</h3>

<p>This method allows you to create animations using CSS transitions. The method takes three arguments, an object literal of CSS values to animate, followed by a value for the duration in milliseconds, and an easing descriptor. If no easing is provided, it defaults to linear, if no duration is provided it defaults to half a second.</p>

<pre class="prettyprint"><code>$("#animate").on('doubletap', function() {
  this.anim(
    {
      "-webkit-transform": "rotate3d(30, 150, 200, 180deg) scale(3) translate3d(-50%, -30%, 140%)",
      "opacity": .25,
      "-webkit-transform-style" : "preserve-3d",
      "-webkit-perspective": 500
    },
    2,
    "ease-in-out"
  );
});
</code></pre>

<p>You can include in the object an optional callback to execute when the animation ends:</p>

<pre class="prettyprint"><code>function saySomething() {
  alert('The animation just ended.');
}

$("#animate").on("click", function() {
  this.anim(
    {
      "-webkit-transform": "rotate3d(30, 150, 200, 180deg) scale(3) translate3d(-50%, -30%, 140%)",
      "opacity": .25,
      "-webkit-transform-style" : "preserve-3d",
      "-webkit-perspective": 500,
      onEnd: saySomething 
    },
    2,
    "ease-in-out");
});
</code></pre>

<h2>
<a name="cc-utilities" class="anchor" href="#utilities" aria-hidden="true"><span class="octicon octicon-link"></span></a>Utilities</h2>

<p>ChocolateChipJS has a number of useful utility properties and methods.</p>

<ul>
<li>$.version</li>
<li>$.libraryName</li>
<li>$.slice()</li>
<li>$.delay()</li>
<li>$.defer()</li>
<li>$.noop</li>
<li>$.concat()</li>
<li>$.w()</li>
<li>$.isString()</li>
<li>$.isArray()</li>
<li>$.isFunction()</li>
<li>$.isObject()</li>
<li>$.isEmptyObject()</li>
<li>$.isNumber()</li>
<li>$.isInteger()</li>
<li>$.isFloat()</li>
<li>$.each()</li>
<li>$.uuiNum()</li>
<li>$.makeUuid()</li>
<li>$.require()</li>
<li>"".camelize()</li>
<li>"".deCamelize()</li>
<li>"".capitalize()</li>
<li>"".capitalizeAll()</li>
</ul><h3>
<a name="cc-version" class="anchor" href="#version" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.version</h3>

<p>The current version of ChocolateChipJS.</p>

<h3>
<a name="cc-libraryname" class="anchor" href="#libraryname" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.libraryName</h3>

<p>If you're not sure whether ChocolateChipJS is running, examine this value. If it returns "ChocolateChip", you know what it is.</p>

<h3>
<a name="cc-slice" class="anchor" href="#slice" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.slice</h3>

<p>This is a shortcut for Array.prototype.slice. You use it to turn any array-like object into an array. This will work for node collections or the arguments object.</p>

<h3>
<a name="cc-delay" class="anchor" href="#delay" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.delay</h3>

<p>This method is used by $.defer to execute a function after the call stack is clear. See $.defer below.</p>

<h3>
<a name="cc-defer" class="anchor" href="#defer" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.defer</h3>

<p>This method will defer the execution of a function until the call stack is clear. This means that even though your function is defined before other code, it will not execute until all of the following code has executed.</p>

<pre class="prettyprint"><code>$(document).ready(function() {
  $.defer(function() {
    console.log("This comes after Squawk!");
  });
  console.log('Squawk!');
  // Result: Squawk! This comes after Squawk!
});
</code></pre>

<h3>
<a name="cc-noop" class="anchor" href="#noop" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.noop</h3>

<p>This is a 'no operation performed' method the you can use when you need a placeholder for a callback. This gets used internally by ChUI.js for cases where it expects a callback but the user may not provide one.</p>

<pre class="prettyprint"><code>// Attach and event that does nothing:
$('button').on('click', $.noop);
</code></pre>

<h3>
<a name="cc-concat" class="anchor" href="#concat" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.concat</h3>

<p>This method allows you to concatenate string or values using a method interface instead of the '+' operator.</p>

<pre class="prettyprint"><code>$(function() {
  // Concatenate a series of arguments:
  var id = ' id="myButton"',
  class = ' class="button"',
  style = ' style="color: red;"';
  var button = $.concat('&lt;button ', id, class, style, '&gt;Button&lt;/button&gt;');
  // Returns: '&lt;button id="myButton" class="button" style="color: red;"&gt;Button&lt;/button&gt;'

  // Concatenate an array of string values:
  var listIems = ['&lt;li&gt;One&lt;/li&gt;','&lt;li&gt;Two&lt;/li&gt;','&lt;li&gt;Three&lt;/li&gt;','&lt;li&gt;Four&lt;/li&gt;']
  var list = $.concat();
  // Returns: '&lt;li&gt;One&lt;/li&gt;&lt;li&gt;Two&lt;/li&gt;&lt;li&gt;Three&lt;/li&gt;&lt;li&gt;Four&lt;/li&gt;'
});
</code></pre>

<h3>
<a name="cc-w" class="anchor" href="#w" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.w</h3>

<p>This method takes a space-delimited string of words and returns it as an array where the inidividual words are indeces.</p>

<pre class="prettyprint"><code>var str = 'This is an example of a string'
var strArray = $.w(str) // Returns ['This','is','an','example','of','a','string']
</code></pre>

<h3>
<a name="cc-isstring" class="anchor" href="#isstring" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.isString</h3>

<p>This method will return true if the argument is a string.</p>

<pre class="prettyprint"><code>$.isString("This is text"); // Will return 'true'
$.isString(1); // Will return 'false';
</code></pre>

<h3>
<a name="cc-isarray" class="anchor" href="#isarray" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.isArray</h3>

<p>This method will return true if the argument is an array.</p>

<pre class="prettyprint"><code>$.isArray([1,2,3]); // Will return 'true'
</code></pre>

<h3>
<a name="cc-isfunction" class="anchor" href="#isfunction" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.isFunction</h3>

<p>This method will return true if the argument is a function.</p>

<pre class="prettyprint"><code>$.isFunction($.noop); // Will return 'true'
</code></pre>

<h3>
<a name="cc-isobject" class="anchor" href="#isobject" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.isObject</h3>

<p>This method will return true if the argument is an object.</p>

<pre class="prettyprint"><code>$.isObject({name: 'Joe Bodoni'}); // Will return 'true'
$.isObject(function() {return}); // Will return 'false'
</code></pre>

<h3>
<a name="cc-isemptyobject" class="anchor" href="#isemptyobject" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.isEmptyObject</h3>

<p>Returns true is the object is empty {}, otherwise it returns false.</p>

<pre class="prettyprint"><code>var newObj = {};
$.isEmptyObject(newObj); // Will return 'true'
$.isEmptyObject(function() {return}); // Will return 'false'
$.isEmptyObject({name: 'Joe Bodoni'}) // Will return 'false'
</code></pre>

<h3>
<a name="cc-isnumber" class="anchor" href="#isnumber" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.isNumber</h3>

<p>This method will return true if the argument is a number.</p>

<pre class="prettyprint"><code>$.isNumber(1); // Will return 'true'
$.isNumber(0.1); // Will return 'true'
$.isNumber('text'); // Will return 'false'
</code></pre>

<h3>
<a name="cc-isinteger" class="anchor" href="#isinteger" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.isInteger</h3>

<p>This method will return true if the argument is an integer.</p>

<pre class="prettyprint"><code>$.isInteger(1); // Will return 'true'
// The following is a float, not an integer:
$.isInteger(1.1); // Will return 'false'
</code></pre>

<h3>
<a name="cc-isfloat" class="anchor" href="#isfloat" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.isFloat</h3>

<p>This method will return true if the argument is a float.</p>

<pre class="prettyprint"><code>$.isFloat(0.1); // Will return 'true'
// This is an integer:
$.isFloat(1); // Will return 'false'
</code></pre>



<h3>
<a name="cc-each" class="anchor" href="#each" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.each</h3>

<p><code>$.each</code> is a method for looping arrays. The default <code>[].forEach()</code> method can sometimes be slow with large arrays. If you are experiencing performance problems with your arrays of nodes, try using this method instead. It takes two arguments, the array and a callback. The callback works just like the callback in the normal foreach array method:</p>

<pre class="prettyprint"><code>var data = ['one', 'two', 'three', 'four', 'five'];
$.each(data, function(ctx, icx) {
  console.log(ctx);
});
</code></pre>

<p>The above will output "one, two, three, four, five".</p>


<h3>
<a name="cc-uuinum" class="anchor" href="#uuinum" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.uuiNum</h3>

<p>This method is used internally by ChocolateChip to create uuids for creating identifiers in its cache for events and data.</p>

<h3>
<a name="cc-makeuuid" class="anchor" href="#makeuuid" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.makeUuid</h3>

<p>Like the $.uuidNum method, this is used internally by ChocolateChip for creating unique identifiers for its caching system.</p>

<h3>
<a name="cc-require" class="anchor" href="#require" aria-hidden="true"><span class="octicon octicon-link"></span></a>$.require</h3>

<p>This method will import a script into your app. You pass it the source for the script and an optional callback to execute when the script is fully parsed by the browser.</p>

<pre class="prettyprint"><code>$.require('/scripts/libs/sillyputty.js', function() {
   var sp = new SillyPutty(); // Will not execute until sillyputty.js is fully loaded.
});
</code></pre>

<h3>
<a name="cc-camelize" class="anchor" href="#camelize" aria-hidden="true"><span class="octicon octicon-link"></span></a>"".camelize</h3>

<p>This method turns a hyphenated string into a camel case string.</p>

<pre class="prettyprint"><code>var camelized = $.camelize('background-color'); // Returns 'backgroundColor'
</code></pre>

<h3>
<a name="cc-decamelize" class="anchor" href="#decamelize" aria-hidden="true"><span class="octicon octicon-link"></span></a>"".deCamelize</h3>

<p>This method converts a camel case string into a hyphenated string.</p>

<pre class="prettyprint"><code>var hyphenated = $.deCamelize('backgroundColor'); // Returns 'background-color'
</code></pre>

<h3>
<a name="cc-capitalize" class="anchor" href="#capitalize" aria-hidden="true"><span class="octicon octicon-link"></span></a>"".capitalize</h3>

<p>This method will capitalize the first letter of a string, as for the first word of a sentence.</p>

<pre class="prettyprint"><code>var word = "chocolate";
word.capitalize(); // returns 'Chocolate'
</code></pre>

<h3>
<a name="cc-capitalizeall" class="anchor" href="#capitalizeall" aria-hidden="true"><span class="octicon octicon-link"></span></a>"".capitalizeAll</h3>

<p>This method will capitalize the first letter of each word in a string.</p>

<pre class="prettyprint"><code>var name = $.capitalize("get out now"); // returns 'Get Out Now'
</code></pre>

<h2>Performance Testing</h2>
<p>We've made some claims about the performance of ChocolateChipJS. You can see for yourself by running any of the following tests. These are all on jsperf.com. </p>
<p>Basic DOM operations:</p>
<ul>
  <li><a href='https://jsperf.com/chocolatechip-vs-jquery-vs-zepto/10' target='_blank'>ChocolateChip vs jQuery vs Zepto (DOM actions)</a></li>
  <li><a href='https://jsperf.com/domsubtreemodified-templates/5' target='_blank'>DOMSubtreeModified &amp; Templates</a></li>
  <li><a href='https://jsperf.com/domnoderemovedfromdocument-templates/6' target='_blank'>DOMNodeRemovedFromDocument &amp; Templates</a></li>
  <li><a href='http://jsperf.com/domrecursiveempty/7' target='_blank'>DOMRecursiveEmpty</a></li>
</ul>
<p>Smackdown between ChocolateChipJS, jQuery &amp; Zepto using templates:</p>
<ul>
  <li><a href='http://jsperf.com/chocolatechipjs-dot/8' target='_blank'>ChocolateChipJS &amp; doT</a></li>
  <li><a href='http://jsperf.com/chocolatechipjs-handlebars/5' target='_blank'>ChocolateChipJS &amp; Handlebars</a></li>
  <li><a href='http://jsperf.com/chocolatechipjs-underscore/5' target='_blank'>ChocolateChipJS &amp; Underscore</a></li>
  <li><a href='http://jsperf.com/jquery-vs-chocolatechip-vs-zepto-dot-vs-handlebars-unde/4' target='_blank'>jQuery vs ChocolateChip vs Zepto &amp; doT vs Handlebars &amp; underscore</a></li>
  <li><a href='http://jsperf.com/testing-chocolatechip-with-templating/20' target='_blank'>jQuery vs ChocolateChip vs Zepto &amp; doT vs Handlebars &amp; underscore</a></li>
</ul>
<p>ChocolateChipJS running various versions of its templating engine:</p>
<ul>
  <li><a href='http://jsperf.com/chocolatechipjs-chtemplate/5' target='_blank'>ChocolateChipJS &amp; chTemplate</a></li>
  <li><a href='http://jsperf.com/choco/4' target='_blank'>ChocolateChip Performance</a></li>
</ul>

<script>
   $(function() {
      $('body').scrollTop(0);
      prettyPrint();
      $('#documentation').trigger('click');
      $('#platformspecifics').addClass('selected');
   });
</script>
